From ccfad443feb3c0f734ae4fd6ee5806d73fec0ffc Mon Sep 17 00:00:00 2001
From: dmitry pervushin <dpervushin@gmail.com>
Date: Fri, 22 Jun 2012 17:03:06 +0200
Subject: [PATCH] Added "missing" files to compile omaplfbwq
To: c-duclos@ti.com

---
 arch/arm/plat-omap/include/plat/sgx_omaplfb.h |   71 +++
 include/linux/bltsville.h                     |  591 +++++++++++++++++++
 include/linux/bvblend.h                       |  507 ++++++++++++++++
 include/linux/bvbuffdesc.h                    |   41 ++
 include/linux/bventry.h                       |   35 ++
 include/linux/bverror.h                       |  300 ++++++++++
 include/linux/bvfilter.h                      |   50 ++
 include/linux/bvinternal.h                    |   46 ++
 include/linux/bvsurfgeom.h                    |   43 ++
 include/linux/ocd.h                           |  781 +++++++++++++++++++++++++
 include/video/dsscomp.h                       |  646 ++++++++++++++++++++
 include/video/omap_hwc.h                      |   27 +
 12 files changed, 3138 insertions(+), 0 deletions(-)
 create mode 100644 arch/arm/plat-omap/include/plat/sgx_omaplfb.h
 create mode 100644 include/linux/bltsville.h
 create mode 100644 include/linux/bvblend.h
 create mode 100644 include/linux/bvbuffdesc.h
 create mode 100644 include/linux/bventry.h
 create mode 100644 include/linux/bverror.h
 create mode 100644 include/linux/bvfilter.h
 create mode 100644 include/linux/bvinternal.h
 create mode 100644 include/linux/bvsurfgeom.h
 create mode 100644 include/linux/ocd.h
 create mode 100644 include/video/dsscomp.h
 create mode 100644 include/video/omap_hwc.h

diff --git a/arch/arm/plat-omap/include/plat/sgx_omaplfb.h b/arch/arm/plat-omap/include/plat/sgx_omaplfb.h
new file mode 100644
index 0000000..66d59b2
--- /dev/null
+++ b/arch/arm/plat-omap/include/plat/sgx_omaplfb.h
@@ -0,0 +1,71 @@
+/*
+ * SGX display class driver platform resources
+ *
+ * Copyright (C) 2012 Texas Instruments
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+#ifndef _ARCH_ARM_PLAT_OMAP_SGX_OMAPLFB_H
+#define _ARCH_ARM_PLAT_OMAP_SGX_OMAPLFB_H
+
+enum sgx_omaplfb_flags {
+	/*
+	 * This flag should be set when we do not want the primary display
+	 * swap chain buffers to be used with an external display.
+	 *
+	 * The number of tiler2d and vram buffers need to be set appropriately
+	 */
+	SGX_OMAPLFB_FLAGS_SDMA_TO_TILER2D_EXTERNAL = 0x00000001,
+};
+
+/*
+ * The settings this platform data entry will determine the type and number of
+ * buffers to use by omaplfb.
+ */
+struct sgx_omaplfb_config {
+	/*
+	 * Number of tiler2d buffers required for display rendering,
+	 * the number of buffers indicated by swap_chain_length will be used
+	 * for the swap chain unless flags indicate otherwise
+	 */
+	u32 tiler2d_buffers;
+	/*
+	 * Number of vram buffers required for display rendering, if no tiler
+	 * buffers are required or flags indicate then the number of buffers
+	 * indicated by swap_chain_length will be used for the swap chain.
+	 */
+	u32 vram_buffers;
+	/*
+	 * Indicate any additional vram that needs to be reserved
+	 */
+	u32 vram_reserve;
+	/*
+	 * Tells omaplfb the number of buffers in the primary swapchain,
+	 * if not set it defaults to 2.
+	 */
+	u32 swap_chain_length;
+	enum sgx_omaplfb_flags flags;
+};
+
+struct sgx_omaplfb_platform_data {
+	u32 num_configs;
+	struct sgx_omaplfb_config *configs;
+};
+
+int sgx_omaplfb_set(unsigned int fbix, struct sgx_omaplfb_config *data);
+struct sgx_omaplfb_config *sgx_omaplfb_get(unsigned int fbix);
+
+#endif
diff --git a/include/linux/bltsville.h b/include/linux/bltsville.h
new file mode 100644
index 0000000..88f7247
--- /dev/null
+++ b/include/linux/bltsville.h
@@ -0,0 +1,591 @@
+/*
+ * bltsville.h
+ *
+ * Copyright (C) 2011 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef BLTSVILLE_H
+#define BLTSVILLE_H
+
+#include "ocd.h"
+#include "bverror.h"
+#include "bvblend.h"
+#include "bvfilter.h"
+#include "bvbuffdesc.h"
+#include "bventry.h"
+#include "bvsurfgeom.h"
+
+/*
+ * bvrect - This structure is used to specify rectangles in BLTsville.
+ */
+struct bvrect {
+	int left;
+	int top;
+	unsigned int width;
+	unsigned int height;
+};
+
+
+/*
+ * BVFLAG_* - These define the type of BLT to be performed and are placed in
+ * the bvparams.flags element.
+ */
+#define BVFLAG_OP_SHIFT	0
+#define BVFLAG_OP_MASK	(0xF << BVFLAG_OP_SHIFT)
+
+/* 0 reserved */
+#define BVFLAG_ROP	(0x1 << BVFLAG_OP_SHIFT) /* ROP4 spec'd in rop */
+#define BVFLAG_BLEND	(0x2 << BVFLAG_OP_SHIFT) /* blend spec'd in blend */
+/* 3 reserved */
+#define BVFLAG_FILTER	(0x4 << BVFLAG_OP_SHIFT) /* filter spec'd in filter */
+/* 5-F reserved */
+
+#define BVFLAG_KEY_SRC		0x00000010 /* source color key - value spec'd
+					      by pcolorkey; Mutually exclusive
+					      with BVFLAG_KEY_DST */
+#define BVFLAG_KEY_DST		0x00000020 /* dest color key - value spec'd
+					      by pcolorkey; Mutually exclusive
+					      with BVFLAG_KEY_SRC */
+#define BVFLAG_CLIP		0x00000040 /* clipping rectangle spec'd by
+					      cliprect */
+#define BVFLAG_SRCMASK		0x00000080 /* when scaling a masked copy, mask
+					      at the source instead of the
+					      (default) destination */
+
+#define BVFLAG_ASYNC		0x00000100 /* call should return once queued */
+
+#define BVFLAG_TILE_SRC1	0x00000200 /* source 1 is tiled */
+#define BVFLAG_TILE_SRC2	0x00000400 /* source 2 is tiled */
+#define BVFLAG_TILE_MASK	0x00000800 /* mask is tiled */
+
+
+#define BVFLAG_BATCH_SHIFT	12
+#define BVFLAG_BATCH_MASK	(3 << BVFLAG_BATCH_SHIFT)
+
+#define BVFLAG_BATCH_NONE	(0 << BVFLAG_BATCH_SHIFT) /* not batched */
+#define BVFLAG_BATCH_BEGIN	(1 << BVFLAG_BATCH_SHIFT) /* begin batch */
+#define BVFLAG_BATCH_CONTINUE	(2 << BVFLAG_BATCH_SHIFT) /* continue batch */
+#define BVFLAG_BATCH_END	(3 << BVFLAG_BATCH_SHIFT) /* end batch */
+
+
+#define BVFLAG_HORZ_FLIP_SRC1	0x00004000 /* flip src1 horizontally */
+#define BVFLAG_VERT_FLIP_SRC1	0x00008000 /* flip src1 vertically */
+#define BVFLAG_HORZ_FLIP_SRC2	0x00010000 /* flip src2 horizontally */
+#define BVFLAG_VERT_FLIP_SRC2	0x00020000 /* flip src2 vertically */
+#define BVFLAG_HORZ_FLIP_MASK	0x00040000 /* flip mask horizontally */
+#define BVFLAG_VERT_FLIP_MASK	0x00080000 /* flip mask vertically */
+
+
+#define BVFLAG_SCALE_RETURN	0x00100000 /* return scale type used */
+#define BVFLAG_DITHER_RETURN	0x00200000 /* return dither type used */
+/**** Bits 31-22 reserved ****/
+
+/*
+ * BVIMPL_* - BLTsville implementations may be combined under managers to
+ * allow clients to take advantage of multiple implementations without doing
+ * so explicitly.  The BVIMPL_* definition are placed into the
+ * bvparams.implementation member by the client to override the manager's
+ * choice of implementation.
+ */
+#define BVIMPL_ANY		0
+#define BVIMPL_FIRST_HW		(1 << 31) /* Continues to the right */
+#define BVIMPL_FIRST_CPU	(1 << 0)  /* Continues to the left */
+
+
+/*
+ * bvscalemode - This specifies the type of scaling to perform.
+ */
+#define BVSCALEDEF_VENDOR_SHIFT 24
+#define BVSCALEDEF_VENDOR_MASK (0xFF << BVSCALEDEF_VENDOR_SHIFT)
+
+#define BVSCALEDEF_VENDOR_ALL (0 << BVSCALEDEF_VENDOR_SHIFT)
+#define BVSCALEDEF_VENDOR_TI  (1 << BVSCALEDEF_VENDOR_SHIFT)
+/* 0xF0-0xFE reserved */
+#define BVSCALEDEF_VENDOR_GENERIC (0xFF << BVSCALEDEF_VENDOR_SHIFT)
+
+/***** VENDOR_GENERIC definitions *****/
+/**** Bits 23-22 indicate classification ****/
+#define BVSCALEDEF_CLASS_SHIFT	22
+#define BVSCALEDEF_IMPLICIT	(0 << BVSCALEDEF_CLASS_SHIFT)
+#define BVSCALEDEF_EXPLICIT	(1 << BVSCALEDEF_CLASS_SHIFT)
+/* 2-3 reserved */
+#define BVSCALEDEF_CLASS_MASK	(3 << BVSCALEDEF_CLASS_MASK)
+
+/**** IMPLICIT definitions ****/
+/*** Bits 21-16 indicate the quality (speed) desired ***/
+#define BVSCALEDEF_QUALITY_SHIFT 16
+#define BVSCALEDEF_FASTEST	(0x00 << BVSCALEDEF_QUALITY_SHIFT)
+#define BVSCALEDEF_GOOD		(0x15 << BVSCALEDEF_QUALITY_SHIFT)
+#define BVSCALEDEF_BETTER	(0x2A << BVSCALEDEF_QUALITY_SHIFT)
+#define BVSCALEDEF_BEST		(0x3F << BVSCALEDEF_QUALITY_SHIFT)
+#define BVSCALEDEF_QUALITY_MASK	(0x3F << BVSCALEDEF_QUALITY_MASK)
+/* Bits 15-12 are reserved */
+/*** Bits 11-8 indicate the desired technique ***/
+#define BVSCALEDEF_TECHNIQUE_SHIFT 8
+#define BVSCALEDEF_DONT_CARE	(0x0 << BVSCALEDEF_TECHNIQUE_SHIFT)
+#define BVSCALEDEF_NOT_NEAREST_NEIGHBOR	(0x1 << BVSCALEDEF_TECHNIQUE_SHIFT)
+#define BVSCALEDEF_POINT_SAMPLE	(0x2 << BVSCALEDEF_TECHNIQUE_SHIFT)
+#define BVSCALEDEF_INTERPOLATED	(0x3 << BVSCALEDEF_TECHNIQUE_SHIFT)
+#define BVSCALEDEF_TECHNIQUE_MASK	(0xF << BVSCALEDEF_TECHNIQUE_SHIFT)
+/* Bits 7-2 reserved */
+/*** Bits 1-0 indicate the type of image ***/
+#define BVSCALEDEF_TYPE_SHIFT 0
+/* 0 don't know */
+#define BVSCALEDEF_PHOTO	(1 << BVSCALEDEF_TYPE_SHIFT)
+#define BVSCALEDEF_DRAWING	(2 << BVSCALEDEF_TYPE_SHIFT)
+/* 3 reserved */
+#define BVSCALEDEF_TYPE_MASK	(3 << BVSCALEDEF_TYPE_MASK)
+
+/**** EXPLICIT definitions ****/
+/* Bits 21-16 reserved */
+#define BVSCALEDEF_HORZ_SHIFT	8
+#define BVSCALEDEF_HORZ_MASK	(0xFF << BVSCALEDEF_HORZ_SHIFT)
+
+#define BVSCALEDEF_VERT_SHIFT	0
+#define BVSCALEDEF_VERT_MASK	(0xFF << BVSCALEDEF_VERT_SHIFT)
+
+#define BVSCALEDEF_NEAREST_NEIGHBOR	0x00
+#define BVSCALEDEF_LINEAR		0x01
+#define BVSCALEDEF_CUBIC		0x02
+#define	BVSCALEDEF_3_TAP		0x03
+/* 0x04 reserved */
+#define BVSCALEDEF_5_TAP		0x05
+/* 0x06 reserved */
+#define BVSCALEDEF_7_TAP		0x07
+/* 0x08 reserved */
+#define BVSCALEDEF_9_TAP		0x09
+/* 0x0A-0xFF reserved */
+
+enum bvscalemode {
+	BVSCALE_FASTEST =	BVSCALEDEF_VENDOR_ALL |
+				BVSCALEDEF_IMPLICIT |
+				BVSCALEDEF_FASTEST |
+				BVSCALEDEF_DONT_CARE,
+	BVSCALE_FASTEST_NOT_NEAREST_NEIGHBOR = BVSCALEDEF_VENDOR_ALL |
+				BVSCALEDEF_IMPLICIT |
+				BVSCALEDEF_FASTEST |
+				BVSCALEDEF_NOT_NEAREST_NEIGHBOR,
+	BVSCALE_FASTEST_POINT_SAMPLE = BVSCALEDEF_VENDOR_ALL |
+				BVSCALEDEF_IMPLICIT |
+				BVSCALEDEF_FASTEST |
+				BVSCALEDEF_POINT_SAMPLE,
+	BVSCALE_FASTEST_INTERPOLATED = BVSCALEDEF_VENDOR_ALL |
+				BVSCALEDEF_IMPLICIT |
+				BVSCALEDEF_FASTEST |
+				BVSCALEDEF_INTERPOLATED,
+	BVSCALE_FASTEST_PHOTO =	BVSCALEDEF_VENDOR_ALL |
+				BVSCALEDEF_IMPLICIT |
+				BVSCALEDEF_FASTEST |
+				BVSCALEDEF_PHOTO,
+	BVSCALE_FASTEST_DRAWING = BVSCALEDEF_VENDOR_ALL |
+				BVSCALEDEF_IMPLICIT |
+				BVSCALEDEF_FASTEST |
+				BVSCALEDEF_DRAWING,
+	BVSCALE_GOOD =		BVSCALEDEF_VENDOR_ALL |
+				BVSCALEDEF_IMPLICIT |
+				BVSCALEDEF_GOOD |
+				BVSCALEDEF_DONT_CARE,
+	BVSCALE_GOOD_POINT_SAMPLE = BVSCALEDEF_VENDOR_ALL |
+				BVSCALEDEF_IMPLICIT |
+				BVSCALEDEF_GOOD |
+				BVSCALEDEF_POINT_SAMPLE,
+	BVSCALE_GOOD_INTERPOLATED = BVSCALEDEF_VENDOR_ALL |
+				BVSCALEDEF_IMPLICIT |
+				BVSCALEDEF_GOOD |
+				BVSCALEDEF_INTERPOLATED,
+	BVSCALE_GOOD_PHOTO =	BVSCALEDEF_VENDOR_ALL |
+				BVSCALEDEF_IMPLICIT |
+				BVSCALEDEF_GOOD |
+				BVSCALEDEF_PHOTO,
+	BVSCALE_GOOD_DRAWING =	BVSCALEDEF_VENDOR_ALL |
+				BVSCALEDEF_IMPLICIT |
+				BVSCALEDEF_GOOD |
+				BVSCALEDEF_DRAWING,
+	BVSCALE_BETTER =	BVSCALEDEF_VENDOR_ALL |
+				BVSCALEDEF_IMPLICIT |
+				BVSCALEDEF_BETTER |
+				BVSCALEDEF_DONT_CARE,
+	BVSCALE_BETTER_POINT_SAMPLE = BVSCALEDEF_VENDOR_ALL |
+				BVSCALEDEF_IMPLICIT |
+				BVSCALEDEF_BETTER |
+				BVSCALEDEF_POINT_SAMPLE,
+	BVSCALE_BETTER_INTERPOLATED = BVSCALEDEF_VENDOR_ALL |
+				BVSCALEDEF_IMPLICIT |
+				BVSCALEDEF_BETTER |
+				BVSCALEDEF_INTERPOLATED,
+	BVSCALE_BETTER_PHOTO =	BVSCALEDEF_VENDOR_ALL |
+				BVSCALEDEF_IMPLICIT |
+				BVSCALEDEF_BETTER |
+				BVSCALEDEF_PHOTO,
+	BVSCALE_BETTER_DRAWING = BVSCALEDEF_VENDOR_ALL |
+				BVSCALEDEF_IMPLICIT |
+				BVSCALEDEF_BETTER |
+				BVSCALEDEF_DRAWING,
+	BVSCALE_BEST =		BVSCALEDEF_VENDOR_ALL |
+				BVSCALEDEF_IMPLICIT |
+				BVSCALEDEF_BEST |
+				BVSCALEDEF_DONT_CARE,
+	BVSCALE_BEST_POINT_SAMPLE = BVSCALEDEF_VENDOR_ALL |
+				BVSCALEDEF_IMPLICIT |
+				BVSCALEDEF_BEST |
+				BVSCALEDEF_POINT_SAMPLE,
+	BVSCALE_BEST_INTERPOLATED = BVSCALEDEF_VENDOR_ALL |
+				BVSCALEDEF_IMPLICIT |
+				BVSCALEDEF_BEST |
+				BVSCALEDEF_INTERPOLATED,
+	BVSCALE_BEST_PHOTO =	BVSCALEDEF_VENDOR_ALL |
+				BVSCALEDEF_IMPLICIT |
+				BVSCALEDEF_BEST |
+				BVSCALEDEF_PHOTO,
+	BVSCALE_BEST_DRAWING =	BVSCALEDEF_VENDOR_ALL |
+				BVSCALEDEF_IMPLICIT |
+				BVSCALEDEF_BEST |
+				BVSCALEDEF_DRAWING,
+
+	BVSCALE_NEAREST_NEIGHBOR = BVSCALEDEF_VENDOR_GENERIC |
+		BVSCALEDEF_EXPLICIT |
+		(BVSCALEDEF_NEAREST_NEIGHBOR << BVSCALEDEF_HORZ_SHIFT) |
+		(BVSCALEDEF_NEAREST_NEIGHBOR << BVSCALEDEF_VERT_SHIFT),
+	BVSCALE_BILINEAR = BVSCALEDEF_VENDOR_GENERIC |
+		BVSCALEDEF_EXPLICIT |
+		(BVSCALEDEF_LINEAR << BVSCALEDEF_HORZ_SHIFT) |
+		(BVSCALEDEF_LINEAR << BVSCALEDEF_VERT_SHIFT),
+	BVSCALE_BICUBIC = BVSCALEDEF_VENDOR_GENERIC |
+		BVSCALEDEF_EXPLICIT |
+		(BVSCALEDEF_CUBIC << BVSCALEDEF_HORZ_SHIFT) |
+		(BVSCALEDEF_CUBIC << BVSCALEDEF_VERT_SHIFT),
+	BVSCALE_3x3_TAP = BVSCALEDEF_VENDOR_GENERIC |
+		BVSCALEDEF_EXPLICIT |
+		(BVSCALEDEF_3_TAP << BVSCALEDEF_HORZ_SHIFT) |
+		(BVSCALEDEF_3_TAP << BVSCALEDEF_VERT_SHIFT),
+	BVSCALE_5x5_TAP = BVSCALEDEF_VENDOR_GENERIC |
+		BVSCALEDEF_EXPLICIT |
+		(BVSCALEDEF_5_TAP << BVSCALEDEF_HORZ_SHIFT) |
+		(BVSCALEDEF_5_TAP << BVSCALEDEF_VERT_SHIFT),
+	BVSCALE_7x7_TAP = BVSCALEDEF_VENDOR_GENERIC |
+		BVSCALEDEF_EXPLICIT |
+		(BVSCALEDEF_7_TAP << BVSCALEDEF_HORZ_SHIFT) |
+		(BVSCALEDEF_7_TAP << BVSCALEDEF_VERT_SHIFT),
+	BVSCALE_9x9_TAP = BVSCALEDEF_VENDOR_GENERIC |
+		BVSCALEDEF_EXPLICIT |
+		(BVSCALEDEF_9_TAP << BVSCALEDEF_HORZ_SHIFT) |
+		(BVSCALEDEF_9_TAP << BVSCALEDEF_VERT_SHIFT),
+
+#ifdef BVSCALE_EXTERNAL_INCLUDE
+#include BVSCALE_EXTERNAL_INCLUDE
+#endif
+};
+
+
+/*
+ * bvdithermode - This defines the type of dithering to use.
+ */
+#define BVDITHERDEF_VENDOR_SHIFT 24
+#define BVDITHERDEF_VENDOR_MASK (0xFF << BVDITHERDEF_VENDOR_SHIFT)
+
+#define BVDITHERDEF_VENDOR_ALL (0 << BVDITHERDEF_VENDOR_SHIFT)
+#define BVDITHERDEF_VENDOR_TI  (1 << BVDITHERDEF_VENDOR_SHIFT)
+/* 0xF0-0xFE reserved */
+#define BVDITHERDEF_VENDOR_GENERIC (0xFF << BVDITHERDEF_VENDOR_SHIFT)
+
+/***** VENDOR_GENERIC definitions *****/
+/* Bits 23-18 reserved */
+/**** Bits 17-16 indicate the type of image - 0 = don't know ****/
+#define BVDITHERDEF_TYPE_SHIFT 16
+#define BVDITHERDEF_PHOTO	(0x01 << BVDITHERDEF_TYPE_SHIFT)
+#define BVDITHERDEF_DRAWING	(0x02 << BVDITHERDEF_TYPE_SHIFT)
+/**** Bits 15-8 indicate the desired technique ****/
+#define BVDITHERDEF_TECHNIQUE_SHIFT 8
+#define BVDITHERDEF_DONT_CARE	(0x00 << BVDITHERDEF_TECHNIQUE_SHIFT)
+#define BVDITHERDEF_RANDOM	(0x01 << BVDITHERDEF_TECHNIQUE_SHIFT)
+#define BVDITHERDEF_ORDERED	(0x02 << BVDITHERDEF_TECHNIQUE_SHIFT)
+#define BVDITHERDEF_DIFFUSED	(0x04 << BVDITHERDEF_TECHNIQUE_SHIFT)
+#define BVDITHERDEF_ON		(0xFF << BVDITHERDEF_TECHNIQUE_SHIFT)
+/**** Bits 7-0 indicate the quality (speed) desired ****/
+#define BVDITHERDEF_QUALITY_SHIFT 0
+#define BVDITHERDEF_FASTEST	(0x00 << BVDITHERDEF_QUALITY_SHIFT)
+#define BVDITHERDEF_GOOD	(0x55 << BVDITHERDEF_QUALITY_SHIFT)
+#define BVDITHERDEF_BETTER	(0xAA << BVDITHERDEF_QUALITY_SHIFT)
+#define BVDITHERDEF_BEST	(0xFF << BVDITHERDEF_QUALITY_SHIFT)
+
+enum bvdithermode {
+	BVDITHER_FASTEST =	BVDITHERDEF_VENDOR_ALL |
+				BVDITHERDEF_FASTEST |
+				BVDITHERDEF_DONT_CARE,
+	BVDITHER_FASTEST_ON =	BVDITHERDEF_VENDOR_ALL |
+				BVDITHERDEF_FASTEST |
+				BVDITHERDEF_ON,
+	BVDITHER_FASTEST_RANDOM = BVDITHERDEF_VENDOR_ALL |
+				BVDITHERDEF_FASTEST |
+				BVDITHERDEF_RANDOM,
+	BVDITHER_FASTEST_ORDERED = BVDITHERDEF_VENDOR_ALL |
+				BVDITHERDEF_FASTEST |
+				BVDITHERDEF_ORDERED,
+	BVDITHER_FASTEST_DIFFUSED = BVDITHERDEF_VENDOR_ALL |
+				BVDITHERDEF_FASTEST |
+				BVDITHERDEF_DIFFUSED,
+	BVDITHER_FASTEST_PHOTO = BVDITHERDEF_VENDOR_ALL |
+				BVDITHERDEF_FASTEST |
+				BVDITHERDEF_PHOTO,
+	BVDITHER_FASTEST_DRAWING = BVDITHERDEF_VENDOR_ALL |
+				BVDITHERDEF_FASTEST |
+				BVDITHERDEF_DRAWING,
+	BVDITHER_GOOD =		BVDITHERDEF_VENDOR_ALL |
+				BVDITHERDEF_GOOD |
+				BVDITHERDEF_DONT_CARE,
+	BVDITHER_GOOD_ON =	BVDITHERDEF_VENDOR_ALL |
+				BVDITHERDEF_GOOD |
+				BVDITHERDEF_ON,
+	BVDITHER_GOOD_RANDOM = BVDITHERDEF_VENDOR_ALL |
+				BVDITHERDEF_GOOD |
+				BVDITHERDEF_RANDOM,
+	BVDITHER_GOOD_ORDERED = BVDITHERDEF_VENDOR_ALL |
+				BVDITHERDEF_GOOD |
+				BVDITHERDEF_ORDERED,
+	BVDITHER_GOOD_DIFFUSED = BVDITHERDEF_VENDOR_ALL |
+				BVDITHERDEF_GOOD |
+				BVDITHERDEF_DIFFUSED,
+	BVDITHER_GOOD_PHOTO =	BVDITHERDEF_VENDOR_ALL |
+				BVDITHERDEF_GOOD |
+				BVDITHERDEF_PHOTO,
+	BVDITHER_GOOD_DRAWING = BVDITHERDEF_VENDOR_ALL |
+				BVDITHERDEF_GOOD |
+				BVDITHERDEF_DRAWING,
+	BVDITHER_BETTER =	BVDITHERDEF_VENDOR_ALL |
+				BVDITHERDEF_BETTER |
+				BVDITHERDEF_DONT_CARE,
+	BVDITHER_BETTER_ON =	BVDITHERDEF_VENDOR_ALL |
+				BVDITHERDEF_BETTER |
+				BVDITHERDEF_ON,
+	BVDITHER_BETTER_RANDOM = BVDITHERDEF_VENDOR_ALL |
+				BVDITHERDEF_BETTER |
+				BVDITHERDEF_RANDOM,
+	BVDITHER_BETTER_ORDERED = BVDITHERDEF_VENDOR_ALL |
+				BVDITHERDEF_BETTER |
+				BVDITHERDEF_ORDERED,
+	BVDITHER_BETTER_DIFFUSED = BVDITHERDEF_VENDOR_ALL |
+				BVDITHERDEF_BETTER |
+				BVDITHERDEF_DIFFUSED,
+	BVDITHER_BETTER_PHOTO =	BVDITHERDEF_VENDOR_ALL |
+				BVDITHERDEF_BETTER |
+				BVDITHERDEF_PHOTO,
+	BVDITHER_BETTER_DRAWING = BVDITHERDEF_VENDOR_ALL |
+				BVDITHERDEF_BETTER |
+				BVDITHERDEF_DRAWING,
+	BVDITHER_BEST =		BVDITHERDEF_VENDOR_ALL |
+				BVDITHERDEF_BEST |
+				BVDITHERDEF_DONT_CARE,
+	BVDITHER_BEST_ON =	BVDITHERDEF_VENDOR_ALL |
+				BVDITHERDEF_BEST |
+				BVDITHERDEF_ON,
+	BVDITHER_BEST_RANDOM = BVDITHERDEF_VENDOR_ALL |
+				BVDITHERDEF_BEST |
+				BVDITHERDEF_RANDOM,
+	BVDITHER_BEST_ORDERED = BVDITHERDEF_VENDOR_ALL |
+				BVDITHERDEF_BEST |
+				BVDITHERDEF_ORDERED,
+	BVDITHER_BEST_DIFFUSED = BVDITHERDEF_VENDOR_ALL |
+				BVDITHERDEF_BEST |
+				BVDITHERDEF_DIFFUSED,
+	BVDITHER_BEST_PHOTO = BVDITHERDEF_VENDOR_ALL |
+				BVDITHERDEF_BEST |
+				BVDITHERDEF_PHOTO,
+	BVDITHER_BEST_DRAWING = BVDITHERDEF_VENDOR_ALL |
+				BVDITHERDEF_BEST |
+				BVDITHERDEF_DRAWING,
+
+	BVDITHER_NONE =		BVDITHERDEF_VENDOR_GENERIC + 0,
+	BVDITHER_ORDERED_2x2 =	BVDITHERDEF_VENDOR_GENERIC + 4,
+	BVDITHER_ORDERED_4x4 =	BVDITHERDEF_VENDOR_GENERIC + 16,
+	BVDITHER_ORDERED_2x2_4x4 = BVDITHERDEF_VENDOR_GENERIC + 4 + 16,
+					/* 2x2 for 6->8, 4x4 for 5->8 */
+
+#ifdef BVDITHER_EXTERNAL_INCLUDE
+#include BVDITHER_EXTERNAL_INCLUDE
+#endif
+};
+
+
+/*
+ * BVTILE_* flags - These specify parameters used when tiling.
+ */
+#define BVTILE_LEFT_SHIFT    0
+#define BVTILE_TOP_SHIFT     (BVTILE_LEFT_SHIFT + 2)
+#define BVTILE_RIGHT_SHIFT   (BVTILE_TOP_SHIFT + 2)
+#define BVTILE_BOTTOM_SHIFT  (BVTILE_RIGHT_SHIFT + 2)
+#define BVTILE_LEFT_REPEAT   (0 << BVTILE_LEFT_SHIFT)	/* ...012301230123 */
+#define BVTILE_TOP_REPEAT    (0 << BVTILE_TOP_SHIFT)	/* ...012301230123 */
+#define BVTILE_RIGHT_REPEAT  (0 << BVTILE_RIGHT_SHIFT)	/* 012301230123... */
+#define BVTILE_BOTTOM_REPEAT (0 << BVTILE_BOTTOM_SHIFT)	/* 012301230123... */
+#define BVTILE_LEFT_MIRROR   (1 << BVTILE_LEFT_SHIFT)	/* ...012332100123 */
+#define BVTILE_TOP_MIRROR    (1 << BVTILE_TOP_SHIFT)	/* ...012332100123 */
+#define BVTILE_RIGHT_MIRROR  (1 << BVTILE_RIGHT_SHIFT)	/* 012332100123... */
+#define BVTILE_BOTTOM_MIRROR (1 << BVTILE_BOTTOM_SHIFT)	/* 012332100123... */
+
+/*
+ * bvtileparams - This structure provides additional parameters needed when
+ * tiling.  This structure replaces the bvbuffdesc in bvbltparams when the
+ * associated BVFLAG_TILE_* flag is set in bvbltparams.flags.
+ */
+struct bvtileparams {
+	unsigned int structsize; /* used to ID structure version */
+	unsigned long flags;	 /* tile flags */
+	void *virtaddr;		 /* pointer to the brush */
+	int dstleft;		 /* horizontal offset */
+	int dsttop;		 /* vertical offset */
+	unsigned int srcwidth;	 /* w/dst width to spec horz scale */
+	unsigned int srcheight;	 /* w/dst height to spec vert scale */
+};
+
+/*
+ * BVBATCH_* - These flags specify the parameters that change between
+ * batched BLTs, when BVFLAG_CONTINUE or BVFLAG_END set.
+ */
+#define BVBATCH_OP		0x00000001 /* type of operation changed */
+#define BVBATCH_KEY		0x00000002 /* color key changed */
+#define BVBATCH_MISCFLAGS	0x00000004 /* other flags changed */
+#define BVBATCH_ALPHA		0x00000008 /* global alpha changed */
+#define BVBATCH_DITHER		0x00000010 /* dither changed */
+#define BVBATCH_SCALE		0x00000020 /* scaling type changed */
+/* Bits 6-7 reserved */
+#define BVBATCH_DST		0x00000100 /* destination surface changed */
+#define BVBATCH_SRC1		0x00000200 /* source 1 surface changed */
+#define BVBATCH_SRC2		0x00000400 /* source 2 surface changed */
+#define BVBATCH_MASK		0x00000800 /* mask surface changed */
+#define BVBATCH_DSTRECT_ORIGIN	0x00001000 /* dest rect origin changed */
+#define BVBATCH_DSTRECT_SIZE	0x00002000 /* dest rect dimensions changed */
+#define BVBATCH_SRC1RECT_ORIGIN	0x00004000 /* src 1 rect origin changed */
+#define BVBATCH_SRC1RECT_SIZE	0x00008000 /* src 1 rect dimensions changed */
+#define BVBATCH_SRC2RECT_ORIGIN	0x00010000 /* src 2 rect origin changed */
+#define BVBATCH_SRC2RECT_SIZE	0x00020000 /* src 2 rect dimensions changed */
+#define BVBATCH_MASKRECT_ORIGIN	0x00040000 /* mask rect origin changed */
+#define BVBATCH_MASKRECT_SIZE	0x00080000 /* mask rect dimensions changed */
+#define BVBATCH_CLIPRECT_ORIGIN	0x00100000 /* Clip rect origin changed */
+#define BVBATCH_CLIPRECT_SIZE	0x00200000 /* Clip rect dimensions changed */
+#define BVBATCH_CLIPRECT	(BVBATCH_CLIPRECT_ORIGIN | \
+				 BVBATCH_CLIPRECT_SIZE)	/* clip rect... */
+							/* ...changed */
+#define BVBATCH_TILE_SRC1	0x00400000 /* tile params for src 1 changed */
+#define BVBATCH_TILE_SRC2	0x00800000 /* tile params for src 2 changed */
+#define BVBATCH_TILE_MASK	0x00100000 /* tile params for mask changed */
+/* Bits 30-21 reserved */
+#define BVBATCH_ENDNOP		0x80000000 /* just end batch, don't do BLT;
+					      only with BVFLAG_BATCH_END */
+
+/*
+ * bvcallbackerror - This structure is passed into the callback function
+ * if an error occurs.
+ */
+struct bvcallbackerror {
+	unsigned int structsize;	/* used to ID structure version */
+	enum bverror error;		/* error during async BLT */
+	char *errdesc;			/* 0-terminated ASCII string
+					   with extended error info (not
+					   for end users) */
+};
+
+/*
+ * bvbatch - an implementation-specific container for batch information;
+ * not used by client; forward declaration here
+ */
+struct bvbatch;
+
+/*
+ * bvinbuff - provides the buffer in bvbltparams
+ */
+union bvinbuff {
+	struct bvbuffdesc *desc;	 /* buffer description when
+					    associated BVFLAG_TILE_*
+					    is not set */
+	struct bvtileparams *tileparams; /* tile params when associated
+					    BVFLAG_TILE_* flag is set */
+};
+
+/*
+ * bvop - used to hold the operation in bvbltparams
+ */
+union bvop {
+	unsigned short rop;		/* when BVFLAG_ROP set */
+	enum bvblend blend;		/* when BVFLAG_BLEND set */
+	struct bvfilter *filter;	/* when BVFLAG_FILTER set */
+};
+
+
+/*
+ * bvbltparams - This structure is passed into bv_blt() to specify the
+ * parameters for a BLT.
+ */
+struct bvbltparams {
+	unsigned int structsize;	/* (i) used to ID structure version */
+	char *errdesc;			/* (o) 0-terminated ASCII string
+					       with extended error info (not
+					       for end users) */
+
+	unsigned long implementation;	/* (i) override manager choice */
+
+	unsigned long flags;		/* (i) see BVFLAG_* above */
+
+	union bvop op;			/* (i) operation; determined by
+					       BVFLAG_OP_MASK bits in flags */
+
+	void *colorkey;			/* (i) pointer to color key pixel
+					       matching non-SUBSAMPLE format
+					       of the keyed surface when
+					       BVFLAG_KEY_* is set */
+
+	union bvalpha globalalpha;	/* (i) global alpha when BVFLAG_BLEND
+					       set in flags and
+					       BVBLENDDEF_GLOBAL_* is set in
+					       blend; typed determined by
+					       BVBLENDDEF_GLOBAL_* */
+
+	enum bvscalemode scalemode;	/* (i/o) type of scaling */
+	enum bvdithermode dithermode;	/* (i/o) type of dither */
+
+	struct bvbuffdesc *dstdesc;	/* (i) dest after bv_map() */
+	struct bvsurfgeom *dstgeom;	/* (i) dest surf fmt and geometry */
+	struct bvrect dstrect;		/* (i) rect into which data written */
+
+	union bvinbuff src1;		/* (i) src1 buffer */
+	struct bvsurfgeom *src1geom;	/* (i) src1 surf fmt and geometry */
+	struct bvrect src1rect;		/* (i) rect from which data is read */
+
+	union bvinbuff src2;		/* (i) src2 buffer */
+	struct bvsurfgeom *src2geom;	/* (i) src2 surf fmt and geometry */
+	struct bvrect src2rect;		/* (i) rect from which data is read */
+
+	union bvinbuff mask;		/* (i) mask buffer */
+	struct bvsurfgeom *maskgeom;	/* (i) mask surf fmt and geometry */
+	struct bvrect maskrect;		/* (i) rect from which data is read */
+
+	struct bvrect cliprect;		/* (i) dest clipping rect when
+					       BVFLAG_CLIP flag set */
+
+	unsigned long batchflags;	/* (i) BVBATCH_* flags used to
+					       indicate params changed between
+					       batch BLTs */
+	struct bvbatch *batch;		/* (i/o) handle for associated batch;
+						 returned when
+						 BVFLAG_BATCH_BEGIN set;
+						 provided to subsequent BLTs
+						 with BVFLAG_BATCH_CONTINUE */
+
+	void (*callbackfn)(struct bvcallbackerror *err,
+			   unsigned long callbackdata); /* (i) callback
+							 function when
+							 BVFLAG_ASYNC is set -
+							 err is 0 when no
+							 error; handle contains
+							 callbackdata below */
+	unsigned long callbackdata;	/* (i) callback data */
+};
+
+#endif /* BLTSVILLE_H */
diff --git a/include/linux/bvblend.h b/include/linux/bvblend.h
new file mode 100644
index 0000000..8e63999
--- /dev/null
+++ b/include/linux/bvblend.h
@@ -0,0 +1,507 @@
+/*
+ * bvblend.h
+ *
+ * Copyright (C) 2011 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+/*
+ * This file defines the types of shared blends available.
+ *
+ * To extend the list of blends, create a file containing additional
+ * enumerations to be added to enum bvblend below.  Then #define
+ * BVBLEND_EXTERNAL_INCLUDE as the name of that file before including
+ * this file in your project.
+ */
+
+#ifndef BVBLEND_H
+#define BVBLEND_H
+
+/*
+ * bvblend - specifies the type of blending operation to perform; only valid
+ *	     when BVFLAG_BLEND is set in the bvbltparams.flags field.
+ */
+
+/*
+ * The blendmode value is divided into two sections.
+ *
+ * [31:28] The most significant 4 bits indicate the blend format.
+ *
+ * [27:0] The remainder of the bits is defined by the format chosen.
+ *
+ *   3322222222221111111111
+ *   10987654321098765432109876543210
+ *   [  ][                          ]
+ *    |               |
+ *  format    defined by format
+ */
+
+#define BVBLENDDEF_FORMAT_SHIFT 28
+#define BVBLENDDEF_FORMAT_MASK (0xF << BVBLENDDEF_FORMAT_SHIFT)
+
+#define BVBLENDDEF_FORMAT_CLASSIC	(0x0 << BVBLENDDEF_FORMAT_SHIFT)
+#define BVBLENDDEF_FORMAT_ESSENTIAL	(0x1 << BVBLENDDEF_FORMAT_SHIFT)
+
+/*
+ * The BVBLENDDEF_FORMAT_CLASSIC is meant to handle the classic Porter-Duff
+ * equations.  It can also handle the DirectFB blending.
+ * BVBLENDDEF_FORMAT_CLASSIC is based on the following equations:
+ *
+ *   Cd = K1 x C1 + K2 x C2
+ *   Ad = K3 x A1 + K4 x A2
+ *
+ * where:
+ *   Cd: destination color
+ *   C1: source 1 color
+ *   C2: source 2 color
+ *   Ad: destination alpha
+ *   A1: source 1 alpha
+ *   A2: source 2 alpha
+ *   K#: one of the constants defined using the bitfields below.
+ */
+
+/*
+ *  The 28 bits for BVBLENDDEF_FORMAT_CLASSIC are divided into 5 sections.
+ *
+ *  The most significant 4 bits are modifiers, used to include additional
+ *  alpha values from global or remote sources.
+ *
+ *  [27] The most significant bit indicates that a remote alpha is to be
+ *  included in the blend.  The format of this is defined by
+ *  bvbltparams.maskgeom.format.
+ *
+ *  [26] The next bit is reserved.
+ *
+ *  [25:24] The next 2 bits are used to indicate that a global alpha is to be
+ *  included, and what its format is:
+ *    00: no global included
+ *    01: global included; bvbltparams.globalalpha.size8 is used (0 -> 255)
+ *    10: this value is reserved
+ *    11: global included; bvbltparams.flogalalpha.fp is used (0.0 -> 1.0)
+ *
+ *  The remaining bits are divided into 4 sections, one to define each of the
+ *  constants:
+ *
+ *  [23:18] - K1
+ *  [17:12] - K2
+ *  [11:6]  - K3
+ *  [5:0]   - K4
+ *
+ *  The format is the same for all 4 constant fields:
+ *
+ *  [5:4] The first 2 bits of each field indicates the way in which the other
+ *  2 fields are interpreted:
+ *    00: only As: the other two fields contain only As; there should be only
+ *                 one valid A value between the two fields
+ *    01: minimum: the value of the constant is the minimum of the two fields
+ *    10: maximum: the value of the constant is the maximum of the two fields
+ *    11: only Cs: the other two fields contain only Cs; there should be only
+ *                 one valid C value between the two fields
+ *
+ *  [3:2] The middle 2 bits of each field contain the inverse field:
+ *    00: 1-C1 ("don't care" for "only As")
+ *    01: 1-A1 ("don't care" for "only Cs")
+ *    10: 1-C2 ("don't care" for "only As")
+ *    11: 1-A2 ("don't care" for "only Cs")
+ *
+ *  [1:0] The last 2 bits if each field contain the normal field:
+ *    00: C1 ("don't care" for "only As")
+ *    01: A1 ("don't care" for "only Cs")
+ *    10: C2 ("don't care" for "only As")
+ *    11: A2 ("don't care" for "only Cs")
+ *
+ *  EXCEPTIONS:
+ *
+ *  00 00 00 - The value 00 00 00, which normally would indicate "only As"
+ *             with two "don't care" fields, is interpreted as a 0.
+ *
+ *  11 11 11 - The value 11 11 11, which normally would indicate "only Cs"
+ *             with two "don't care" fields, is interpreted as a 1.
+ *
+ * --------------------------------------------------------------------------
+ *
+ * Put together, these can define portions of the blend equations that can be
+ * put together in a variety of ways:
+ *
+ *   00 00 00: undefined -> zero
+ *   00 00 01: A1 (preferred)
+ *   00 00 10: undefined
+ *   00 00 11: A2 (preferred)
+ *   00 01 00: 1-A1 (preferred)
+ *   00 01 01: undefined
+ *   00 01 10: 1-A1 (use 00 01 00)
+ *   00 01 11: undefined
+ *   00 10 00: undefined
+ *   00 10 01: A1 (use 00 00 01)
+ *   00 10 10: undefined
+ *   00 10 11: A2 (use 00 00 11)
+ *   00 11 00: 1-A2 (preferred)
+ *   00 11 01: undefined
+ *   00 11 10: 1-A2 (use 00 11 00)
+ *   00 11 11: undefined
+ *
+ *   01 00 00: min(C1,1-C1)
+ *   01 00 01: min(A1,1-C1)
+ *   01 00 10: min(C2,1-C1)
+ *   01 00 11: min(A2,1-C1)
+ *   01 01 00: min(C1,1-A1)
+ *   01 01 01: min(A1,1-A1)
+ *   01 01 10: min(C2,1-A1)
+ *   01 01 11: min(A2,1-A1)
+ *   01 10 00: min(C1,1-C2)
+ *   01 10 01: min(A1,1-C2)
+ *   01 10 10: min(C2,1-C2)
+ *   01 10 11: min(A2,1-C2)
+ *   01 11 00: min(C1,1-A2)
+ *   01 11 01: min(A1,1-A2)
+ *   01 11 10: min(C2,1-A2)
+ *   01 11 11: min(A2,1-A2)
+ *
+ *   10 00 00: max(C1,1-C1)
+ *   10 00 01: max(A1,1-C1)
+ *   10 00 10: max(C2,1-C1)
+ *   10 00 11: max(A2,1-C1)
+ *   10 01 00: max(C1,1-A1)
+ *   10 01 01: max(A1,1-A1)
+ *   10 01 10: max(C2,1-A1)
+ *   10 01 11: max(A2,1-A1)
+ *   10 10 00: max(C1,1-C2)
+ *   10 10 01: max(A1,1-C2)
+ *   10 10 10: max(C2,1-C2)
+ *   10 10 11: max(A2,1-C2)
+ *   10 11 00: max(C1,1-A2)
+ *   10 11 01: max(A1,1-A2)
+ *   10 11 10: max(C2,1-A2)
+ *   10 11 11: max(A2,1-A2)
+ *
+ *   11 00 00: undefined
+ *   11 00 01: 1-C1 (use 11 00 11)
+ *   11 00 10: undefined
+ *   11 00 11: 1-C1 (preferred)
+ *   11 01 00: C1 (use 11 11 00)
+ *   11 01 01: undefined
+ *   11 01 10: C2 (use 11 11 10)
+ *   11 01 11: undefined
+ *   11 10 00: undefined
+ *   11 10 01: 1-C2 (use 11 10 11)
+ *   11 10 10: undefined
+ *   11 10 11: 1-C2 (preferred)
+ *   11 11 00: C1 (preferred)
+ *   11 11 01: undefined
+ *   11 11 10: C2 (preferred)
+ *   11 11 11: undefined -> one
+ *
+ * ==========================================================================
+ * DirectFB
+ * ==========================================================================
+ *
+ * Putting these together into the proper constants, the blending equations
+ * can be built for DirectFB as well:
+ *
+ * For DirectFB, the SetSrcBlendFunction() and SetDstBlendFunction() can
+ * specify 121 combinations of blends (11 x 11). It's impractical to
+ * specify these combinations individually. Instead, the settings indicated
+ * by each call should be bitwise OR'd to make the proper single value used in
+ * BLTsville.
+ *
+ * binary value <- SetSrcBlendFunction()
+ *           [--K1--] [--K2--] [--K3--] [--K4--]
+ * 0000 0000 00 00 00 xx xx xx 00 00 00 xx xx xx <- DSBF_ZERO
+ * 0000 0000 11 11 11 xx xx xx 11 11 11 xx xx xx <- DSBF_ONE
+ * 0000 0000 11 11 00 xx xx xx 00 00 01 xx xx xx <- DSBF_SRCCOLOR
+ * 0000 0000 11 00 11 xx xx xx 00 01 00 xx xx xx <- DSBF_INVSRCCOLOR
+ * 0000 0000 00 00 01 xx xx xx 00 00 01 xx xx xx <- DSBF_SRCALPHA
+ * 0000 0000 00 01 00 xx xx xx 00 01 00 xx xx xx <- DSBF_INVSRCALPHA
+ * 0000 0000 11 11 10 xx xx xx 00 00 11 xx xx xx <- DSBF_DESTCOLOR
+ * 0000 0000 11 10 11 xx xx xx 00 11 00 xx xx xx <- DSBF_INVDESTCOLOR
+ * 0000 0000 00 00 11 xx xx xx 00 00 11 xx xx xx <- DSBF_DESTALPHA
+ * 0000 0000 00 11 00 xx xx xx 00 11 00 xx xx xx <- DSBF_INVDESTALPHA
+ * 0000 0000 01 11 01 xx xx xx 11 11 11 xx xx xx <- DSBF_SRCALPHASAT
+ *
+ * binary value <- SetDstBlendFunction()
+ *           [--K1--] [--K2--] [--K3--] [--K4--]
+ * 0000 0000 xx xx xx 00 00 00 xx xx xx 00 00 00 <- DSBF_ZERO
+ * 0000 0000 xx xx xx 11 11 11 xx xx xx 11 11 11 <- DSBF_ONE
+ * 0000 0000 xx xx xx 11 11 00 xx xx xx 00 00 01 <- DSBF_SRCCOLOR
+ * etc.
+ *
+ * ==========================================================================
+ * Porter-Duff
+ * ==========================================================================
+ *
+ * For Porter-Duff, the equations can be more specifically defined. For
+ * convenience, these are enumerated below. These utilize the local alpha as
+ * indicated. To use global or remote alpha, these enumerations need to be
+ * modified. For example, to include the global alpha in the Porter-Duff
+ * SRC1OVER blend, the blend could be defined like this:
+ *   params.op.blend = BVBLEND_SRC1OVER +
+ *                     BVBLENDDEF_GLOBAL_UCHAR;
+ *
+ * To include the remote alpha, the blend could be defined like this:
+ *   params.op.blend = BVBLEND_SRC1OVER +
+ *                     BVBLENDDEF_REMOTE;
+ *
+ * And to include both:
+ *   params.op.blend = BVBLEND_SRC1OVER +
+ *                     BVBLENDDEF_GLOBAL_UCHAR +
+ *                     BVBLENDDEF_REMOTE;
+ *
+ * Note that if the source color formats include local alphas, the local
+ * alphas, global alpha, and remote alpha will be used together.
+ *
+ * Note also that the equations assume the surfaces are premultiplied. So
+ * if the surface formats indicate that they are not premultiplied, the
+ * alpha multiplication of each color is done prior to using the surface
+ * values in the equations.
+ *
+ * For example, BVBLEND_SRC1OVER specifies the equations:
+ *   Cd = 1 x C1 + (1 - A1) x C2
+ *   Ad = 1 x A1 + (1 - A1) x A2
+ *
+ * If the format of surface 1 is non-premultiplied, the equations
+ * are modified to include the multiplication explicitly:
+ *   Cd = 1 x A1 x C1 + (1 - A1) x C2
+ *   Ad = 1 x A1      + (1 - A1) x A2
+ *
+ * Likewise, if the format of surface 2 is non-premultiplied, the
+ * equations are modified for this:
+ *   Cd = 1 x C1 + (1 - A1) x A2 x C2
+ *   Ad = 1 x A1 + (1 - A1) x A2
+ *
+ * When including global or remote alphas, these values are used to modify
+ * the source 1 value values before being used in the blend equation:
+ *   C1 = Ag x C1
+ *   A1 = Ag x A1
+ *       -or-
+ *   C1 = Ar x C1
+ *   A1 = Ar x A1
+ *       -or-
+ *   C1 = Ag x Ar x C1
+ *   A1 = Ag x Ar x A1
+ *
+ */
+
+#define BVBLENDDEF_MODE_SHIFT	4
+#define BVBLENDDEF_INV_SHIFT	2
+#define BVBLENDDEF_NORM_SHIFT	0
+
+#define BVBLENDDEF_ONLY_A	(0 << BVBLENDDEF_MODE_SHIFT)
+#define BVBLENDDEF_MIN		(1 << BVBLENDDEF_MODE_SHIFT)
+#define BVBLENDDEF_MAX		(2 << BVBLENDDEF_MODE_SHIFT)
+#define BVBLENDDEF_ONLY_C	(3 << BVBLENDDEF_MODE_SHIFT)
+#define BVBLENDDEF_MODE_MASK	(3 << BVBLENDDEF_MODE_SHIFT)
+
+#define BVBLENDDEF_NORM_C1	(0 << BVBLENDDEF_NORM_SHIFT)
+#define BVBLENDDEF_NORM_A1	(1 << BVBLENDDEF_NORM_SHIFT)
+#define BVBLENDDEF_NORM_C2	(2 << BVBLENDDEF_NORM_SHIFT)
+#define BVBLENDDEF_NORM_A2	(3 << BVBLENDDEF_NORM_SHIFT)
+#define BVBLENDDEF_NORM_MASK	(3 << BVBLENDDEF_NORM_SHIFT)
+
+#define BVBLENDDEF_INV_C1	(0 << BVBLENDDEF_INV_SHIFT)
+#define BVBLENDDEF_INV_A1	(1 << BVBLENDDEF_INV_SHIFT)
+#define BVBLENDDEF_INV_C2	(2 << BVBLENDDEF_INV_SHIFT)
+#define BVBLENDDEF_INV_A2	(3 << BVBLENDDEF_INV_SHIFT)
+#define BVBLENDDEF_INV_MASK	(3 << BVBLENDDEF_INV_SHIFT)
+
+#define BVBLENDDEF_ONLY_A_NORM_xx	BVBLENDDEF_NORM_C1
+#define BVBLENDDEF_ONLY_A_INV_xx	BVBLENDDEF_INV_C1
+#define BVBLENDDEF_ONLY_C_NORM_xx	BVBLENDDEF_NORM_A2
+#define BVBLENDDEF_ONLY_C_INV_xx	BVBLENDDEF_INV_A2
+
+#define BVBLENDDEF_ZERO \
+	(BVBLENDDEF_ONLY_A | \
+	 BVBLENDDEF_ONLY_A_NORM_xx | \
+	 BVBLENDDEF_ONLY_A_INV_xx)
+#define BVBLENDDEF_C1 \
+	(BVBLENDDEF_ONLY_C | \
+	 BVBLENDDEF_NORM_C1 | \
+	 BVBLENDDEF_ONLY_C_INV_xx)
+#define BVBLENDDEF_A1 \
+	(BVBLENDDEF_ONLY_A | \
+	 BVBLENDDEF_NORM_A1 | \
+	 BVBLENDDEF_ONLY_A_INV_xx)
+#define BVBLENDDEF_C2 \
+	(BVBLENDDEF_ONLY_C | \
+	 BVBLENDDEF_NORM_C2 | \
+	 BVBLENDDEF_ONLY_C_INV_xx)
+#define BVBLENDDEF_A2 \
+	(BVBLENDDEF_ONLY_A | \
+	 BVBLENDDEF_NORM_A2 | \
+	 BVBLENDDEF_ONLY_A_INV_xx)
+#define BVBLENDDEF_ONE_MINUS_C1 \
+	(BVBLENDDEF_ONLY_C | \
+	 BVBLENDDEF_ONLY_C_NORM_xx | \
+	 BVBLENDDEF_INV_C1)
+#define BVBLENDDEF_ONE_MINUS_A1 \
+	(BVBLENDDEF_ONLY_A | \
+	 BVBLENDDEF_ONLY_A_NORM_xx | \
+	 BVBLENDDEF_INV_A1)
+#define BVBLENDDEF_ONE_MINUS_C2 \
+	(BVBLENDDEF_ONLY_C | \
+	 BVBLENDDEF_ONLY_C_NORM_xx | \
+	 BVBLENDDEF_INV_C2)
+#define BVBLENDDEF_ONE_MINUS_A2 \
+	(BVBLENDDEF_ONLY_A | \
+	 BVBLENDDEF_ONLY_A_NORM_xx | \
+	 BVBLENDDEF_INV_A2)
+#define BVBLENDDEF_ONE \
+	(BVBLENDDEF_ONLY_C | \
+	 BVBLENDDEF_ONLY_C_NORM_xx | \
+	 BVBLENDDEF_ONLY_C_INV_xx)
+
+#define BVBLENDDEF_K_MASK \
+	(BVBLENDDEF_MODE_MASK | \
+	 BVBLENDDEF_INV_MASK  | \
+	 BVBLENDDEF_NORM_MASK)
+
+#define BVBLENDDEF_K1_SHIFT 18
+#define BVBLENDDEF_K2_SHIFT 12
+#define BVBLENDDEF_K3_SHIFT 6
+#define BVBLENDDEF_K4_SHIFT 0
+
+#define BVBLENDDEF_K1_MASK \
+	(BVBLENDDEF_K_MASK << BVBLENDDEF_K1_SHIFT)
+#define BVBLENDDEF_K2_MASK \
+	(BVBLENDDEF_K_MASK << BVBLENDDEF_K2_SHIFT)
+#define BVBLENDDEF_K3_MASK \
+	(BVBLENDDEF_K_MASK << BVBLENDDEF_K3_SHIFT)
+#define BVBLENDDEF_K4_MASK \
+	(BVBLENDDEF_K_MASK << BVBLENDDEF_K4_SHIFT)
+
+#define BVBLENDDEF_CLASSIC_EQUATION_MASK 0x00FFFFFF
+
+/*
+ * The following definitions are be used to modify the enumerations.
+ */
+#define BVBLENDDEF_REMOTE	0x08000000	/* mask surface provides alpha
+						   for source 1 */
+
+/* Bit 26 reserved */
+
+/* These enable global alpha and define the type of globalalpha */
+#define BVBLENDDEF_GLOBAL_SHIFT 24
+#define BVBLENDDEF_GLOBAL_MASK	(3 << BVBLENDDEF_GLOBAL_SHIFT)
+
+#define BVBLENDDEF_GLOBAL_NONE	(0 << BVBLENDDEF_GLOBAL_SHIFT)
+#define BVBLENDDEF_GLOBAL_UCHAR	(1 << BVBLENDDEF_GLOBAL_SHIFT)
+/* 2 reserved */
+#define BVBLENDDEF_GLOBAL_FLOAT	(3 << BVBLENDDEF_GLOBAL_SHIFT)
+
+union bvalpha {
+	unsigned char size8;	/* btwn 0 (0.0) and 255 (1.0) */
+	float fp;		/* btwn 0.0 and 1.0 */
+};
+
+
+enum bvblend {
+  /* Porter-Duff blending equations */
+	BVBLEND_CLEAR = BVBLENDDEF_FORMAT_CLASSIC |
+			(BVBLENDDEF_ZERO << BVBLENDDEF_K1_SHIFT) |
+			(BVBLENDDEF_ZERO << BVBLENDDEF_K2_SHIFT) |
+			(BVBLENDDEF_ZERO << BVBLENDDEF_K3_SHIFT) |
+			(BVBLENDDEF_ZERO << BVBLENDDEF_K4_SHIFT),
+	BVBLEND_SRC1 =	BVBLENDDEF_FORMAT_CLASSIC |
+			(BVBLENDDEF_ONE << BVBLENDDEF_K1_SHIFT) |
+			(BVBLENDDEF_ZERO << BVBLENDDEF_K2_SHIFT) |
+			(BVBLENDDEF_ONE << BVBLENDDEF_K3_SHIFT) |
+			(BVBLENDDEF_ZERO << BVBLENDDEF_K4_SHIFT),
+	BVBLEND_SRC2 =	BVBLENDDEF_FORMAT_CLASSIC |
+			(BVBLENDDEF_ZERO << BVBLENDDEF_K1_SHIFT) |
+			(BVBLENDDEF_ONE << BVBLENDDEF_K2_SHIFT) |
+			(BVBLENDDEF_ZERO << BVBLENDDEF_K3_SHIFT) |
+			(BVBLENDDEF_ONE << BVBLENDDEF_K4_SHIFT),
+	BVBLEND_SRC1OVER = BVBLENDDEF_FORMAT_CLASSIC |
+			(BVBLENDDEF_ONE << BVBLENDDEF_K1_SHIFT) |
+			(BVBLENDDEF_ONE_MINUS_A1 << BVBLENDDEF_K2_SHIFT) |
+			(BVBLENDDEF_ONE << BVBLENDDEF_K3_SHIFT) |
+			(BVBLENDDEF_ONE_MINUS_A1 << BVBLENDDEF_K4_SHIFT),
+	BVBLEND_SRC2OVER = BVBLENDDEF_FORMAT_CLASSIC |
+			(BVBLENDDEF_ONE_MINUS_A2 << BVBLENDDEF_K1_SHIFT) |
+			(BVBLENDDEF_ONE << BVBLENDDEF_K2_SHIFT) |
+			(BVBLENDDEF_ONE_MINUS_A2 << BVBLENDDEF_K3_SHIFT) |
+			(BVBLENDDEF_ONE << BVBLENDDEF_K4_SHIFT),
+	BVBLEND_SRC1IN = BVBLENDDEF_FORMAT_CLASSIC |
+			(BVBLENDDEF_A2 << BVBLENDDEF_K1_SHIFT) |
+			(BVBLENDDEF_ZERO << BVBLENDDEF_K2_SHIFT) |
+			(BVBLENDDEF_A2 << BVBLENDDEF_K3_SHIFT) |
+			(BVBLENDDEF_ZERO << BVBLENDDEF_K4_SHIFT),
+	BVBLEND_SRC2IN = BVBLENDDEF_FORMAT_CLASSIC |
+			(BVBLENDDEF_ZERO << BVBLENDDEF_K1_SHIFT) |
+			(BVBLENDDEF_A1 << BVBLENDDEF_K2_SHIFT) |
+			(BVBLENDDEF_ZERO << BVBLENDDEF_K3_SHIFT) |
+			(BVBLENDDEF_A1 << BVBLENDDEF_K4_SHIFT),
+	BVBLEND_SRC1OUT = BVBLENDDEF_FORMAT_CLASSIC |
+			(BVBLENDDEF_ONE_MINUS_A2 << BVBLENDDEF_K1_SHIFT) |
+			(BVBLENDDEF_ZERO << BVBLENDDEF_K2_SHIFT) |
+			(BVBLENDDEF_ONE_MINUS_A2 << BVBLENDDEF_K3_SHIFT) |
+			(BVBLENDDEF_ZERO << BVBLENDDEF_K4_SHIFT),
+	BVBLEND_SRC2OUT = BVBLENDDEF_FORMAT_CLASSIC |
+			(BVBLENDDEF_ZERO << BVBLENDDEF_K1_SHIFT) |
+			(BVBLENDDEF_ONE_MINUS_A1 << BVBLENDDEF_K2_SHIFT) |
+			(BVBLENDDEF_ZERO << BVBLENDDEF_K3_SHIFT) |
+			(BVBLENDDEF_ONE_MINUS_A1 << BVBLENDDEF_K4_SHIFT),
+	BVBLEND_SRC1ATOP = BVBLENDDEF_FORMAT_CLASSIC |
+			(BVBLENDDEF_A2 << BVBLENDDEF_K1_SHIFT) |
+			(BVBLENDDEF_ONE_MINUS_A1 << BVBLENDDEF_K2_SHIFT) |
+			(BVBLENDDEF_A2 << BVBLENDDEF_K3_SHIFT) |
+			(BVBLENDDEF_ONE_MINUS_A1 << BVBLENDDEF_K4_SHIFT),
+	BVBLEND_SRC2ATOP = BVBLENDDEF_FORMAT_CLASSIC |
+			(BVBLENDDEF_ONE_MINUS_A2 << BVBLENDDEF_K1_SHIFT) |
+			(BVBLENDDEF_A1 << BVBLENDDEF_K2_SHIFT) |
+			(BVBLENDDEF_ONE_MINUS_A2 << BVBLENDDEF_K3_SHIFT) |
+			(BVBLENDDEF_A1 << BVBLENDDEF_K4_SHIFT),
+	BVBLEND_XOR = BVBLENDDEF_FORMAT_CLASSIC |
+			(BVBLENDDEF_ONE_MINUS_A2 << BVBLENDDEF_K1_SHIFT) |
+			(BVBLENDDEF_ONE_MINUS_A1 << BVBLENDDEF_K2_SHIFT) |
+			(BVBLENDDEF_ONE_MINUS_A2 << BVBLENDDEF_K3_SHIFT) |
+			(BVBLENDDEF_ONE_MINUS_A1 << BVBLENDDEF_K4_SHIFT),
+	BVBLEND_PLUS = BVBLENDDEF_FORMAT_CLASSIC |
+			(BVBLENDDEF_ONE << BVBLENDDEF_K1_SHIFT) |
+			(BVBLENDDEF_ONE << BVBLENDDEF_K2_SHIFT) |
+			(BVBLENDDEF_ONE << BVBLENDDEF_K3_SHIFT) |
+			(BVBLENDDEF_ONE << BVBLENDDEF_K4_SHIFT),
+
+/*
+ * For FORMAT_ESSENTIAL, the variety of well-known blending functions from
+ * popular image manipulation programs are specified.
+ */
+
+	BVBLEND_NORMAL = BVBLENDDEF_FORMAT_ESSENTIAL + 0,
+	BVBLEND_LIGHTEN = BVBLENDDEF_FORMAT_ESSENTIAL + 1,
+	BVBLEND_DARKEN = BVBLENDDEF_FORMAT_ESSENTIAL + 2,
+	BVBLEND_MULTIPLY = BVBLENDDEF_FORMAT_ESSENTIAL + 3,
+	BVBLEND_AVERAGE = BVBLENDDEF_FORMAT_ESSENTIAL + 4,
+	BVBLEND_ADD = BVBLENDDEF_FORMAT_ESSENTIAL + 5,
+	BVBLEND_LINEAR_DODGE = BVBLEND_ADD,
+	BVBLEND_SUBTRACT = BVBLENDDEF_FORMAT_ESSENTIAL + 6,
+	BVBLEND_LINEAR_BURN = BVBLEND_SUBTRACT,
+	BVBLEND_DIFFERENCE = BVBLENDDEF_FORMAT_ESSENTIAL + 7,
+	BVBLEND_NEGATE = BVBLENDDEF_FORMAT_ESSENTIAL + 8,
+	BVBLEND_SCREEN = BVBLENDDEF_FORMAT_ESSENTIAL + 9,
+	BVBLEND_EXCLUSION = BVBLENDDEF_FORMAT_ESSENTIAL + 10,
+	BVBLEND_OVERLAY = BVBLENDDEF_FORMAT_ESSENTIAL + 11,
+	BVBLEND_SOFT_LIGHT = BVBLENDDEF_FORMAT_ESSENTIAL + 12,
+	BVBLEND_HARD_LIGHT = BVBLENDDEF_FORMAT_ESSENTIAL + 13,
+	BVBLEND_COLOR_DODGE = BVBLENDDEF_FORMAT_ESSENTIAL + 14,
+	BVBLEND_COLOR_BURN = BVBLENDDEF_FORMAT_ESSENTIAL + 15,
+	BVBLEND_LINEAR_LIGHT = BVBLENDDEF_FORMAT_ESSENTIAL + 16,
+	BVBLEND_VIVID_LIGHT = BVBLENDDEF_FORMAT_ESSENTIAL + 17,
+	BVBLEND_PIN_LIGHT = BVBLENDDEF_FORMAT_ESSENTIAL + 18,
+	BVBLEND_HARD_MIX = BVBLENDDEF_FORMAT_ESSENTIAL + 19,
+	BVBLEND_REFLECT = BVBLENDDEF_FORMAT_ESSENTIAL + 20,
+	BVBLEND_GLOW = BVBLENDDEF_FORMAT_ESSENTIAL + 21,
+	BVBLEND_PHOENIX = BVBLENDDEF_FORMAT_ESSENTIAL + 22,
+
+#ifdef BVBLEND_EXTERNAL_INCLUDE
+#define BVBLEND_EXTERNAL_INCLUDE
+#endif
+};
+
+#endif /* BVBLEND_H */
diff --git a/include/linux/bvbuffdesc.h b/include/linux/bvbuffdesc.h
new file mode 100644
index 0000000..543b5d1
--- /dev/null
+++ b/include/linux/bvbuffdesc.h
@@ -0,0 +1,41 @@
+/*
+ * bvbuffdesc.h
+ *
+ * Copyright (C) 2011 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef BVBUFFDESC_H
+#define BVBUFFDESC_H
+
+/*
+ * bvbuffmap - This is a private structure used by BLTsville
+ * implementations to manage resources associated with a buffer.  A pointer
+ * to this is returned from bv_map() and used in subsequent bv_blt() and
+ * bv_unmap() calls.
+ */
+struct bvbuffmap;
+
+/*
+ * bvbuffdesc - This structure is used to specify the buffer parameters
+ * in a call to bv_map().
+ */
+struct bvbuffdesc {
+	unsigned int structsize;	/* used to identify struct version */
+	void *virtaddr;			/* virtual ptr to start of buffer */
+	unsigned long length;		/* length of the buffer in bytes */
+	struct bvbuffmap *map;		/* resource(s) associated w/buffer */
+	unsigned long pagesize;		/* page size in bytes */
+	unsigned long *pagearray;	/* array of physical page addresses */
+	unsigned int pagecount;		/* number of pages in the page array */
+	unsigned long pageoffset;	/* page offset in bytes */
+};
+
+#endif /* BVBUFFDESC_H */
diff --git a/include/linux/bventry.h b/include/linux/bventry.h
new file mode 100644
index 0000000..d26fec9
--- /dev/null
+++ b/include/linux/bventry.h
@@ -0,0 +1,35 @@
+/*
+ * bventry.h
+ *
+ * Copyright (C) 2011 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef BVENTRY_H
+#define BVENTRY_H
+
+/* Forward declarations */
+struct bvbuffdesc;
+struct bvbltparams;
+
+/*
+ * BLTsville interface definition.
+ */
+typedef enum bverror (*BVFN_MAP) (struct bvbuffdesc *buffdesc);
+typedef enum bverror (*BVFN_UNMAP) (struct bvbuffdesc *buffdesc);
+typedef enum bverror (*BVFN_BLT) (struct bvbltparams *bltparams);
+
+struct bventry {
+	BVFN_MAP bv_map;
+	BVFN_UNMAP bv_unmap;
+	BVFN_BLT bv_blt;
+};
+
+#endif /* BVENTRY_H */
diff --git a/include/linux/bverror.h b/include/linux/bverror.h
new file mode 100644
index 0000000..3aa2977
--- /dev/null
+++ b/include/linux/bverror.h
@@ -0,0 +1,300 @@
+/*
+ * bverror.h
+ *
+ * Copyright (C) 2011 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef BVERROR_H
+#define BVERROR_H
+
+/*
+ * bverror - These are error codes returned by BLTsville functions.
+ */
+#define BVERRDEF_VENDOR_SHIFT	24
+#define BVERRDEF_VENDOR_MASK	(0xFF << BVERRDEF_VENDOR_SHIFT)
+
+#define BVERRDEF_VENDOR_ALL	(0x00 << BVERRDEF_VENDOR_SHIFT)
+#define BVERRDEF_VENDOR_TI	(0x01 << BVERRDEF_VENDOR_SHIFT)
+/* 0xF0-0xFF reserved */
+
+enum bverror {
+	BVERR_NONE = 0,		/* no error */
+
+	BVERR_UNK =		/* unknown error */
+		BVERRDEF_VENDOR_ALL + 1,
+	BVERR_OOM =		/* memory allocation failure */
+		BVERRDEF_VENDOR_ALL + 2,
+	BVERR_RSRC =		/* required resource unavailable */
+		BVERRDEF_VENDOR_ALL + 3,
+
+	BVERR_VIRTADDR =	/* virtaddr is bad */
+		BVERRDEF_VENDOR_ALL + 1000,
+	BVERR_VIRTPTR =
+		BVERR_VIRTADDR,	/* for backwards compatibility*/
+
+	BVERR_BUFFERDESC =	/* invalid bvbufferdesc */
+		BVERRDEF_VENDOR_ALL + 10000,
+	BVERR_BUFFERDESC_VERS =	/* bvbufferdesc.structsize too small */
+		BVERRDEF_VENDOR_ALL + 11000,
+	BVERR_BUFFERDESC_VIRTADDR = /* bad bvbufferdesc.virtaddr */
+		BVERRDEF_VENDOR_ALL + 12000,
+	BVERR_BUFFERDESC_LEN =	/* bvbufferdesc.length not supported */
+		BVERRDEF_VENDOR_ALL + 13000,
+	BVERR_BUFFERDESC_ALIGNMENT = /* unsupported buffer base address */
+		BVERRDEF_VENDOR_ALL + 14000,
+
+	BVERR_BLTPARAMS_VERS =	/* bvbltparams.structsize too small */
+		BVERRDEF_VENDOR_ALL + 20000,
+	BVERR_IMPLEMENTATION =	/* bvbltparams.implementation unsupported */
+		BVERRDEF_VENDOR_ALL + 21000,
+	BVERR_FLAGS =		/* bvbltparams.flags unsupported */
+		BVERRDEF_VENDOR_ALL + 22000,
+	BVERR_OP =		/* unsupported operation */
+		BVERRDEF_VENDOR_ALL + 22100,
+	BVERR_KEY =		/* type of color key not supported */
+		BVERRDEF_VENDOR_ALL + 22200,
+	BVERR_SRC1_TILE =	/* src1 tiling not supported */
+		BVERRDEF_VENDOR_ALL + 22300,
+	BVERR_SRC2_TILE =	/* src2 tiling not supported */
+		BVERRDEF_VENDOR_ALL + 22310,
+	BVERR_MASK_TILE =	/* mask tiling not supported */
+		BVERRDEF_VENDOR_ALL + 22320,
+	BVERR_FLIP =		/* flipping not supported */
+		BVERRDEF_VENDOR_ALL + 22400,
+	BVERR_ROP =		/* ROP code not supported */
+		BVERRDEF_VENDOR_ALL + 23000,
+	BVERR_BLEND =		/* blend not supported */
+		BVERRDEF_VENDOR_ALL + 23100,
+	BVERR_GLOBAL_ALPHA =	/* type of global alpha not supported */
+		BVERRDEF_VENDOR_ALL + 23110,
+	BVERR_FILTER =		/* filter type not supported */
+		BVERRDEF_VENDOR_ALL + 23200,
+	BVERR_FILTER_PARAMS_VERS = /* filter parameter structsize too small */
+		BVERRDEF_VENDOR_ALL + 23210,
+	BVERR_FILTER_PARAMS =	/* filter parameters not supported */
+		BVERRDEF_VENDOR_ALL + 23220,
+	BVERR_SCALE_MODE =	/* bvbltparams.scalemode not supported */
+		BVERRDEF_VENDOR_ALL + 24000,
+	BVERR_DITHER_MODE =	/* bvbltparams.dithermode not supported */
+		BVERRDEF_VENDOR_ALL + 25000,
+
+	BVERR_DSTDESC =		/* invalid bvbltparams.dstdesc */
+		BVERRDEF_VENDOR_ALL + 26000,
+	BVERR_DSTDESC_VERS =	/* bvbufferdesc.structsize too small */
+		BVERRDEF_VENDOR_ALL + 26100,
+	BVERR_DSTDESC_VIRTADDR = /* bad bvbufferdesc.virtaddr */
+		BVERRDEF_VENDOR_ALL + 26200,
+	BVERR_DSTDESC_LEN =	/* bvbufferdesc.length not supported */
+		BVERRDEF_VENDOR_ALL + 26300,
+	BVERR_DST_ALIGNMENT =	/* unsupported buffer base address */
+		BVERRDEF_VENDOR_ALL + 26400,
+
+	BVERR_DSTGEOM =		/* invalid bvbltparams.dstgeom */
+		BVERRDEF_VENDOR_ALL + 27000,
+	BVERR_DSTGEOM_VERS =	/* dstgeom.structsize too small */
+		BVERRDEF_VENDOR_ALL + 27100,
+	BVERR_DSTGEOM_FORMAT =	/* bltparams.dstgeom.format not supported */
+		BVERRDEF_VENDOR_ALL + 27200,
+	BVERR_DSTGEOM_STRIDE =	/* bltparams.dstgeom.stride not supported */
+		BVERRDEF_VENDOR_ALL + 27300,
+	BVERR_DSTGEOM_PALETTE =	/* dstgeom.paletteformat not supported */
+		BVERRDEF_VENDOR_ALL + 27400,
+
+
+	BVERR_DSTRECT =		/* bvbltparams.dstrect not supported */
+		BVERRDEF_VENDOR_ALL + 28000,
+
+	BVERR_SRC1DESC =	/* invalid bvbltparams.src1.desc */
+		BVERRDEF_VENDOR_ALL + 29000,
+	BVERR_SRC1DESC_VERS =	/* bvbufferdesc.structsize too small */
+		BVERRDEF_VENDOR_ALL + 29100,
+	BVERR_SRC1DESC_VIRTADDR = /* bad bvbufferdesc.virtaddr */
+		BVERRDEF_VENDOR_ALL + 29200,
+	BVERR_SRC1DESC_LEN =	/* bvbufferdesc.length not supported */
+		BVERRDEF_VENDOR_ALL + 29300,
+	BVERR_SRC1DESC_ALIGNMENT = /* unsupported buffer base address */
+		BVERRDEF_VENDOR_ALL + 29400,
+
+	BVERR_SRC1GEOM =	/* invalid bvbltparams.src1geom */
+		BVERRDEF_VENDOR_ALL + 30000,
+	BVERR_SRC1GEOM_VERS =	/* src1geom.structsize too small */
+		BVERRDEF_VENDOR_ALL + 30100,
+	BVERR_SRC1GEOM_FORMAT =	/* bltparams.src1geom.format not supported */
+		BVERRDEF_VENDOR_ALL + 30200,
+	BVERR_SRC1GEOM_STRIDE =	/* bltparams.src1geom.stride not supported */
+		BVERRDEF_VENDOR_ALL + 30300,
+	BVERR_SRC1GEOM_PALETTE = /* src1geom.paletteformat not supported */
+		BVERRDEF_VENDOR_ALL + 30400,
+
+	BVERR_SRC1RECT =	/* bvbltparams.src1rect not supported */
+		BVERRDEF_VENDOR_ALL + 31000,
+
+	BVERR_SRC1_HORZSCALE = /* horz scale for src1->dst not supported */
+		BVERRDEF_VENDOR_ALL + 31100,
+	BVERR_SRC1_VERTSCALE =	/* vert scale for src1->dst not supported */
+		BVERRDEF_VENDOR_ALL + 31200,
+	BVERR_SRC1_ROT =	/* src1->dst rotation angle not supported */
+		BVERRDEF_VENDOR_ALL + 31300,
+
+	BVERR_SRC1_TILEPARAMS =	/* invalid src1.tileparams */
+		BVERR_SRC1DESC,
+	BVERR_SRC1_TILE_VERS =	/* src1.tileparams.structsize too small */
+		BVERRDEF_VENDOR_ALL + 32000,
+	BVERR_SRC1_TILEPARAMS_VERS =
+		BVERR_SRC1_TILE_VERS,
+	BVERR_SRC1_TILE_FLAGS =	/* tileparams.flags not supported */
+		BVERRDEF_VENDOR_ALL + 32100,
+	BVERR_SRC1_TILEPARAMS_FLAGS =
+		BVERR_SRC1_TILE_FLAGS,
+	BVERR_SRC1_TILE_VIRTADDR =
+		BVERR_SRC1DESC_VIRTADDR,
+	BVERR_SRC1_TILEPARAMS_VIRTADDR =
+		BVERR_SRC1_TILE_VIRTADDR,
+	BVERR_SRC1_TILE_ORIGIN = /* tileparams.left or .top not supported */
+		BVERRDEF_VENDOR_ALL + 32200,
+	BVERR_SRC1_TILEPARAMS_ORIGIN =
+		BVERR_SRC1_TILE_ORIGIN,
+	BVERR_SRC1_TILE_SIZE =	/* tileparams.width or .height not supported */
+		BVERRDEF_VENDOR_ALL + 32300,
+	BVERR_SRC1_TILEPARAMS_SIZE =
+		BVERR_SRC1_TILE_SIZE,
+
+	BVERR_SRC2DESC =	/* invalid bvbltparams.src2.desc */
+		BVERRDEF_VENDOR_ALL + 33000,
+	BVERR_SRC2DESC_VERS =	/* bvbufferdesc.structsize too small */
+		BVERRDEF_VENDOR_ALL + 33100,
+	BVERR_SRC2DESC_VIRTADDR = /* bad bvbufferdesc.virtaddr */
+		BVERRDEF_VENDOR_ALL + 33200,
+	BVERR_SRC2DESC_LEN =	/* bvbufferdesc.length not supported */
+		BVERRDEF_VENDOR_ALL + 33300,
+	BVERR_SRC2DESC_ALIGNMENT = /* unsupported buffer base address */
+		BVERRDEF_VENDOR_ALL + 33400,
+
+	BVERR_SRC2GEOM =	/* invalid bvbltparams.src2geom */
+		BVERRDEF_VENDOR_ALL + 34000,
+	BVERR_SRC2GEOM_VERS =	/* src2geom.structsize too small */
+		BVERRDEF_VENDOR_ALL + 34100,
+	BVERR_SRC2GEOM_FORMAT =	/* bltparams.src2geom.format not supported */
+		BVERRDEF_VENDOR_ALL + 34200,
+	BVERR_SRC2GEOM_STRIDE =	/* bltparams.src2geom.stride not supported */
+		BVERRDEF_VENDOR_ALL + 34300,
+	BVERR_SRC2GEOM_PALETTE = /* src2geom.paletteformat not supported */
+		BVERRDEF_VENDOR_ALL + 34400,
+
+	BVERR_SRC2RECT =	/* bvbltparams.src2rect not supported */
+		BVERRDEF_VENDOR_ALL + 35000,
+
+	BVERR_SRC2_HORZSCALE = /* horz scale for src2->dst not supported */
+		BVERRDEF_VENDOR_ALL + 35100,
+	BVERR_SRC2_VERTSCALE =	/* vert scale for src2->dst not supported */
+		BVERRDEF_VENDOR_ALL + 35200,
+	BVERR_SRC2_ROT =	/* src2->dst rotation angle not supported */
+		BVERRDEF_VENDOR_ALL + 35300,
+
+	BVERR_SRC2_TILEPARAMS =	/* invalid src2.tileparams */
+		BVERR_SRC2DESC,
+	BVERR_SRC2_TILE_VERS =	/* src2.tileparams.structsize too small */
+		BVERRDEF_VENDOR_ALL + 36000,
+	BVERR_SRC2_TILEPARAMS_VERS =
+		BVERR_SRC2_TILE_VERS,
+	BVERR_SRC2_TILE_FLAGS =	/* tileparams.flags not supported */
+		BVERRDEF_VENDOR_ALL + 36100,
+	BVERR_SRC2_TILEPARAMS_FLAGS =
+		BVERR_SRC2_TILE_FLAGS,
+	BVERR_SRC2_TILE_VIRTADDR =
+		BVERR_SRC2DESC_VIRTADDR,
+	BVERR_SRC2_TILEPARAMS_VIRTADDR =
+		BVERR_SRC2_TILE_VIRTADDR,
+	BVERR_SRC2_TILE_ORIGIN = /* tileparams.left or .top not supported */
+		BVERRDEF_VENDOR_ALL + 36200,
+	BVERR_SRC2_TILEPARAMS_ORIGIN =
+		BVERR_SRC2_TILE_ORIGIN,
+	BVERR_SRC2_TILE_SIZE =	/* tileparams.width or .height not supported */
+		BVERRDEF_VENDOR_ALL + 36300,
+	BVERR_SRC2_TILEPARAMS_SIZE =
+		BVERR_SRC2_TILE_SIZE,
+
+	BVERR_MASKDESC =	/* invalid bvbltparams.mask.desc */
+		BVERRDEF_VENDOR_ALL + 37000,
+	BVERR_MASKDESC_VERS =	/* bvbufferdesc.structsize too small */
+		BVERRDEF_VENDOR_ALL + 37100,
+	BVERR_MASKDESC_VIRTADDR = /* bad bvbufferdesc.virtaddr */
+		BVERRDEF_VENDOR_ALL + 37200,
+	BVERR_MASKDESC_LEN =	/* bvbufferdesc.length not supported */
+		BVERRDEF_VENDOR_ALL + 37300,
+	BVERR_MASKDESC_ALIGNMENT = /* unsupported buffer base address */
+		BVERRDEF_VENDOR_ALL + 37400,
+
+	BVERR_MASKGEOM =	/* invalid bvbltparams.maskgeom */
+		BVERRDEF_VENDOR_ALL + 38000,
+	BVERR_MASKGEOM_VERS =	/* maskgeom.structsize too small */
+		BVERRDEF_VENDOR_ALL + 38100,
+	BVERR_MASKGEOM_FORMAT =	/* bltparams.maskgeom.format not supported */
+		BVERRDEF_VENDOR_ALL + 38200,
+	BVERR_MASKGEOM_STRIDE =	/* bltparams.maskgeom.stride not supported */
+		BVERRDEF_VENDOR_ALL + 38300,
+	BVERR_MASKGEOM_PALETTE = /* maskgeom.paletteformat not supported */
+		BVERRDEF_VENDOR_ALL + 38400,
+
+	BVERR_MASKRECT =	/* bvbltparams.maskrect not supported */
+		BVERRDEF_VENDOR_ALL + 39000,
+
+	BVERR_MASK_HORZSCALE = /* horz scale for mask->dst not supported */
+		BVERRDEF_VENDOR_ALL + 39100,
+	BVERR_MASK_VERTSCALE =	/* vert scale for mask->dst not supported */
+		BVERRDEF_VENDOR_ALL + 39200,
+	BVERR_MASK_ROT =	/* mask->dst rotation angle not supported */
+		BVERRDEF_VENDOR_ALL + 39300,
+
+	BVERR_MASK_TILEPARAMS =	/* invalid mask.tileparams */
+		BVERR_MASKDESC,
+	BVERR_MASK_TILE_VERS =	/* mask.tileparams.structsize too small */
+		BVERRDEF_VENDOR_ALL + 40000,
+	BVERR_MASK_TILEPARAMS_VERS =
+		BVERR_MASK_TILE_VERS,
+	BVERR_MASK_TILE_FLAGS =	/* tileparams.flags not supported */
+		BVERRDEF_VENDOR_ALL + 40100,
+	BVERR_MASK_TILEPARAMS_FLAGS =
+		BVERR_MASK_TILE_FLAGS,
+	BVERR_MASK_TILE_VIRTADDR =
+		BVERR_MASKDESC_VIRTADDR,
+	BVERR_MASK_TILEPARAMS_VIRTADDR =
+		BVERR_MASK_TILE_VIRTADDR,
+	BVERR_MASK_TILE_ORIGIN = /* tileparams.left or .top not supported */
+		BVERRDEF_VENDOR_ALL + 40200,
+	BVERR_MASK_TILEPARAMS_ORIGIN =
+		BVERR_MASK_TILE_ORIGIN,
+	BVERR_MASK_TILE_SIZE =	/* tileparams.width or .height not supported */
+		BVERRDEF_VENDOR_ALL + 40300,
+	BVERR_MASK_TILEPARAMS_SIZE =
+		BVERR_MASK_TILE_SIZE,
+
+	BVERR_CLIP_RECT =	/* bvbltparams.cliprect not supported */
+		BVERRDEF_VENDOR_ALL + 41000,
+
+	BVERR_BATCH_FLAGS =	/* bvbltparams.batchflags not supported */
+		BVERRDEF_VENDOR_ALL + 42000,
+	BVERR_BATCH =		/* bvbltparams.batch not valid */
+		BVERRDEF_VENDOR_ALL + 43000,
+
+	BVERR_OP_FAILED =	/* async operation failed to start */
+		BVERRDEF_VENDOR_ALL + 50000,
+	BVERR_OP_INCOMPLETE =	/* async operation failed mid-way */
+		BVERRDEF_VENDOR_ALL + 50001,
+	BVERR_MEMORY_ERROR =	/* async operation triggered memory error */
+		BVERRDEF_VENDOR_ALL + 51000,
+
+#ifdef BVERR_EXTERNAL_INCLUDE
+#include BVERR_EXTERNAL_INCLUDE
+#endif
+};
+
+#endif /* BVERROR_H */
diff --git a/include/linux/bvfilter.h b/include/linux/bvfilter.h
new file mode 100644
index 0000000..f472529
--- /dev/null
+++ b/include/linux/bvfilter.h
@@ -0,0 +1,50 @@
+/*
+ * bvfilter.h
+ *
+ * Copyright (C) 2011 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+/*
+ * This file defines the types of shared filters available and the associated
+ * parameters.
+ *
+ * To extend the list of filters, create a file containing additional
+ * enumerations to be added to enum bvfilter below.  Then #define
+ * BVFILTER_EXTERNAL_INCLUDE as the name of that file before including
+ * this file in your project.  Parameters need to be in a different file.
+ */
+
+#ifndef BVFILTER_H
+#define BVFILTER_H
+
+/*
+ * bvfilter is an enumeration used to designate the type of filter being used.
+ */
+enum bvfiltertype {
+	BVFILTER_DUMMY
+	/* TBD */
+
+#ifdef BVFILTER_EXTERNAL_INCLUDE
+#include BVFILTER_EXTERNAL_INCLUDE
+#endif
+};
+
+/*
+ * bvfilterop contains the filter type and a pointer to the associated
+ * parameters when the BVFLAG_FILTER operation is specified in
+ * bvbltparams.flags.
+ */
+struct bvfilter {
+	enum bvfiltertype filter;
+	void *params;
+};
+
+#endif /* BVFILTER_H */
diff --git a/include/linux/bvinternal.h b/include/linux/bvinternal.h
new file mode 100644
index 0000000..82648b5
--- /dev/null
+++ b/include/linux/bvinternal.h
@@ -0,0 +1,46 @@
+/*
+ * bvinternal.h
+ *
+ * Copyright (C) 2011 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+/*
+ * This file contains definitions used by implementations of BLTsville
+ * 2-D libraries.  It should not be used by clients.
+ */
+
+#ifndef BVINTERNAL_H
+#define BVINTENRAL_H
+
+/*
+ * bvbuffmap - The bvbuffmap structure is used to track resources
+ * associated with a buffer, such as a h/w MMU entry.  The implementations
+ * add bvbuffmap objects when they allocate the resources.  Then when a
+ * buffer is accessed, the implementations can regain access to the
+ * associated resources.  The implementations allocate and populate this
+ * structure when a bv_map() call is made.  It is used in subsequent
+ * bv_blt() and bv_unmap() calls.  The latter frees the associated resource
+ * and the structure (if applicable).  Note that a given resource might be
+ * used by more than one implementation.
+ */
+struct bvbuffmap {
+	unsigned int structsize; /* used to ID structure ver */
+
+	/* function to unmap this resource */
+	BVFN_UNMAP bv_unmap;
+
+	unsigned long handle;	 /* resource-specific info */
+
+	/* pointer to next resource mapping structure */
+	struct bvbuffmap *nextmap;
+};
+
+#endif /* BVINTERNAL_H */
diff --git a/include/linux/bvsurfgeom.h b/include/linux/bvsurfgeom.h
new file mode 100644
index 0000000..924e45a
--- /dev/null
+++ b/include/linux/bvsurfgeom.h
@@ -0,0 +1,43 @@
+/*
+ * bvsurfgeom.h
+ *
+ * Copyright (C) 2011 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef BVSURFGEOM_H
+#define BVSURFGEOM_H
+
+/*
+ * bvsurfdesc - This structure specifies the way a buffer should be used in a
+ * 2-D context.
+ */
+
+struct bvsurfgeom {
+	unsigned int structsize;	/* used to identify struct version */
+	enum ocdformat format;		/* color format of surface */
+	unsigned int width;		/* width of the surface in pixels */
+	unsigned int height;		/* height of the surface in lines */
+	int orientation;		/* angle of the surface in degrees
+					   (multiple of 90 only) */
+	long virtstride;		/* distance from one pixel to the
+					   pixel immediately below it in
+					   virtual space */
+	enum ocdformat paletteformat;	/* format of palette */
+	void *palette;			/* array of palette entries of
+					   paletteformat; only valid when
+					   format includes BVFMTDEF_LUT;
+					   number of entries is 2^bpp. */
+	long physstride;		/* distance from one pixel to the
+					   pixel immediately below it in
+					   physical address space */
+};
+
+#endif /* BVSURFGEOM_H */
diff --git a/include/linux/ocd.h b/include/linux/ocd.h
new file mode 100644
index 0000000..250b7a1
--- /dev/null
+++ b/include/linux/ocd.h
@@ -0,0 +1,781 @@
+/*
+ * ocd.h
+ *
+ * Open Color format Definitions
+ *
+ * Copyright (C) 2011 Texas Instruments, Inc.
+ *
+ * This file defines the Open Color format Definitions (OCD), an open,
+ * extensible, color format definition.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef OCD_H
+#define OCD_H
+
+/*
+ * ocdformat - specifies one of the supported color formats
+ *
+ * ocdformat consists of 8 bits indicating the vendor ID, followed by 24 bits
+ * specified by the vendor.
+ *
+ * VENDOR_ALL is a common ID with formats defined below.
+ */
+
+/****** Bits 31-24 are the vendor ID. The other 24 are vendor defined. ******/
+#define OCDFMTDEF_VENDOR_SHIFT 24
+#define OCDFMTDEF_VENDOR_MASK (0xFF << OCDFMTDEF_VENDOR_SHIFT)
+
+#define OCDFMTDEF_VENDOR_ALL \
+	(0x00 << OCDFMTDEF_VENDOR_SHIFT) /* Common format */
+#define OCDFMTDEF_VENDOR_TI  \
+	(0x01 << OCDFMTDEF_VENDOR_SHIFT) /* Texas Instruments, Inc. */
+/* 0xF0-0xFF reserved */
+
+/***** OCDFMTDEF_VENDOR_ALL *****/
+/* The formats in this group are created using combinations of the values
+   listed below. */
+
+/*
+ * 33222222 222 21 1  1  1  11 111  1
+ * 10987654 321 09 8  7  6  54 321  0  9 876 543210
+ * [------] [-] [] |  |  |  [] [-]  |  | [-] [----]
+ *    |      |  |  |  |  |  |   |   |  |  |    |
+ *    |      |  |  |  |  |  |   |   |  |  |  color bits minus 1
+ *    |      |  |  |  |  |  |   |   |  |  |
+ *    |      |  |  |  |  |  |   |   |  | container
+ *    |      |  |  |  |  |  |   |   |  |
+ *    |      |  |  |  |  |  |   |   | left justified
+ *    |      |  |  |  |  |  |   |   |
+ *    |      |  |  |  |  |  |   | reversed
+ *    |      |  |  |  |  |  |   |
+ *    |      |  |  |  |  |  | layout
+ *    |      |  |  |  |  |  |
+ *    |      |  |  |  |  | subsampling
+ *    |      |  |  |  |  |
+ *    |      |  |  |  | subsample position     \
+ *    |      |  |  |  |			       |
+ *    |      |  |  | non-premult/fill empty 0	> alpha components
+ *    |      |  |  |			       |
+ *    |      |  | alpha			       /
+ *    |      |  |
+ *    |      | standard
+ *    |      |
+ *    |    color space
+ *    |
+ * vendor ID (VENDOR_ALL = 0x00)
+ */
+
+/**** Bits 23-21 define the color space. ****/
+#define OCDFMTDEF_CS_SHIFT 21
+#define OCDFMTDEF_CS_MASK (7 << OCDFMTDEF_CS_SHIFT)
+
+#define OCDFMTDEF_CS_MONO \
+	(0 << OCDFMTDEF_CS_SHIFT) /* Monochrome (luma only) */
+#define OCDFMTDEF_CS_LUT \
+	(1 << OCDFMTDEF_CS_SHIFT) /* Look-up table (using palette) */
+#define OCDFMTDEF_CS_RGB \
+	(2 << OCDFMTDEF_CS_SHIFT) /* Red, green, blue */
+#define OCDFMTDEF_CS_YCbCr \
+	(3 << OCDFMTDEF_CS_SHIFT) /* YCbCr (YUV) (luma & chroma) */
+#define OCDFMTDEF_CS_ALPHA \
+	(4 << OCDFMTDEF_CS_SHIFT) /* Alpha only (transparency) */
+/* 5 reserved */
+/* 6 reserved */
+/* 7 reserved */
+
+/**** Bits 20-19 define the standard ****/
+#define OCDFMTDEF_STD_SHIFT 19
+#define OCDFMTDEF_STD_MASK (3 << OCDFMTDEF_STD_SHIFT)
+
+#define OCDFMTDEF_STD_ITUR_601_YCbCr \
+	(0 << OCDFMTDEF_STD_SHIFT) /* ITU-R BT.601 - YCbCr only */
+/* 0 default for non-YCbCr */
+#define OCDFMTDEF_STD_ITUR_709_YCbCr \
+	(1 << OCDFMTDEF_STD_SHIFT) /* ITU-R BT.709 - YCbCr only */
+/* 1 reserved for non-YCbCr */
+/* 2 reserved */
+#define OCDFMTDEF_FULLSCALE_YCbCr \
+	(3 << OCDFMTDEF_STD_SHIFT) /* RGB 0 to 255 =>
+				      YCbCr 0 to 255, -128 to 127 */
+/* 3 reserved for non-YCbCr */
+
+/**** Bits 18-16 are component modifiers for non-alpha c/s only ****/
+#define OCDFMTDEF_ALPHA	\
+	(1 << 18) /* An alpha component is added to the format */
+#define OCDFMTDEF_NON_PREMULT \
+	(1 << 17) /* Component(s) is(are) not premultiplied by the alpha
+		     (default is premultiplied) */
+#define OCDFMTDEF_FILL_EMPTY_0 \
+	(1 << 17) /* Empty bits are hard-wired to 0 (default is 1) */
+#define OCDFMTDEF_SUBSAMPLE_HORZ_ALIGNED \
+	(0 << 16) /* Subsamples aligned w/1st non-subsample (e.g. MPEG-2) */
+#define OCDFMTDEF_SUBSAMPLE_HORZ_CENTERED \
+	(1 << 16) /* Subsamples are between non-subsamples (e.g. MPEG-1) */
+
+/*** Bits 18-16 are used differently for alpha c/s ***/
+/* Bit 18 is reserved */
+/*** Bits 17-16 define the number of alpha components for alpha c/s ***/
+#define OCDFMTDEF_ALPHA_COMPONENTS_SHIFT 16
+#define OCDFMTDEF_ALPHA_COMPONENTS_MASK (3 << OCDFMTDEF_ALPHA_COMPONENTS_SHIFT)
+
+#define OCDFMTDEF_ALPHA_COMPONENTS_1 (0 << OCDFMTDEF_ALPHA_COMPONENTS_SHIFT)
+#define OCDFMTDEF_ALPHA_COMPONENTS_2 (1 << OCDFMTDEF_ALPHA_COMPONENTS_SHIFT)
+#define OCDFMTDEF_ALPHA_COMPONENTS_3 (2 << OCDFMTDEF_ALPHA_COMPONENTS_SHIFT)
+#define OCDFMTDEF_ALPHA_COMPONENTS_4 (3 << OCDFMTDEF_ALPHA_COMPONENTS_SHIFT)
+
+/**** Bits 15-14 define subsampling ****/
+#define OCDFMTDEF_SUBSAMPLE_SHIFT 14
+#define OCDFMTDEF_SUBSAMPLE_MASK	(3 << OCDFMTDEF_SUBSAMPLE_SHIFT)
+
+#define OCDFMTDEF_SUBSAMPLE_NONE \
+	(0 << OCDFMTDEF_SUBSAMPLE_SHIFT) /* No subsampling;
+					    each pixel has each component */
+#define OCDFMTDEF_SUBSAMPLE_422_YCbCr \
+	(1 << OCDFMTDEF_SUBSAMPLE_SHIFT) /* 4:2:2 subsampling;
+					    each horizontal pair of pixels
+					    has one Y (luma) component each,
+					    but shares one Cb and Cr (chroma)
+					    component. */
+/* 1 reserved for non-YCbCr */
+#define OCDFMTDEF_SUBSAMPLE_420_YCbCr \
+	(2 << OCDFMTDEF_SUBSAMPLE_SHIFT) /* 4:2:0 subsampling;
+					    each square of four pixels has
+					    one Y (luma) component each, but
+					    shares one Cb and Cr (chroma)
+					    component. */
+/* 2 reserved for non-YCbCr */
+#define OCDFMTDEF_SUBSAMPLE_411_YCbCr \
+	(3 << OCDFMTDEF_SUBSAMPLE_SHIFT) /* 4:1:1 subsampling;
+					    each horizontal four pixels have
+					    one Y (luma) component each, but
+					    shares one Cb and Cr (chroma)
+					    component. */
+/* 3 reserved for non-YCbCr */
+
+/**** Bits 13-11 define the memory layout
+      (combined with _REVERSED and _LEFT_JUSTIFIED) ****/
+#define OCDFMTDEF_LAYOUT_SHIFT 11
+#define OCDFMTDEF_LAYOUT_MASK (7 << OCDFMTDEF_LAYOUT_SHIFT)
+
+#define OCDFMTDEF_PACKED \
+	(0 << OCDFMTDEF_LAYOUT_SHIFT) /* Components interleaved together */
+#define OCDFMTDEF_DISTRIBUTED \
+	(1 << OCDFMTDEF_LAYOUT_SHIFT) /* Components are distributed evenly
+					 across the container; e.g. a 64-bit
+					 container with four 8-bit components
+					 are distributed with 8 bits between
+					 them: __C0__C1__C2__C3 */
+#define OCDFMTDEF_2_PLANE_YCbCr \
+	(2 << OCDFMTDEF_LAYOUT_SHIFT) /* Y component is separated from Cb & Cr
+					 components.  After the Y plane, an
+					 interleaved CbCr plane follows. */
+/* 2 reserved for non-YCbCr */
+#define OCDFMTDEF_3_PLANE_STACKED \
+	(3 << OCDFMTDEF_LAYOUT_SHIFT) /* Y, Cb, and Cr components are
+					 separated.  After the Y plane is a Cb
+					 plane, and then a Cr plane. */
+/* 3 reserved for non-YCbCr and non-RGB */
+/* 4 reserved */
+/* 5 reserved */
+/* 6 reserved */
+#define OCDFMTDEF_3_PLANE_SIDE_BY_SIDE_YCbCr \
+	(7 << OCDFMTDEF_LAYOUT_SHIFT) /* Y, Cb, and Cr components are
+					 separated.  After the Y plane the Cb
+					 and Cr planes are separated but
+					 side-by-side in memory (interleaved
+					 on a line-by-line basis). */
+/* 7 reserved for non-YCbCr */
+
+/**** Bits 10-9 are layout modifiers. ****/
+#define OCDFMTDEF_REVERSED \
+	(1 << 10) /* Order of components reversed (default is RGB or CbCr) */
+#define OCDFMTDEF_LEFT_JUSTIFIED \
+	(1 << 9) /* Components are shifted left (default is shifted right);
+		    for 3-plane YCbCr, this indicates wasted space to the
+		    right of the Cb & Cr planes (stride matches Y plane). */
+
+/**** Bits 6-8 specify the container type. ****/
+#define OCDFMTDEF_CONTAINER_SHIFT 6
+#define OCDFMTDEF_CONTAINER_MASK (7 << OCDFMTDEF_CONTAINER_SHIFT)
+
+#define OCDFMTDEF_CONTAINER_8BIT  (0 << OCDFMTDEF_CONTAINER_SHIFT)
+#define OCDFMTDEF_CONTAINER_16BIT (1 << OCDFMTDEF_CONTAINER_SHIFT)
+#define OCDFMTDEF_CONTAINER_24BIT (2 << OCDFMTDEF_CONTAINER_SHIFT)
+#define OCDFMTDEF_CONTAINER_32BIT (3 << OCDFMTDEF_CONTAINER_SHIFT)
+/* 4 (0x008000) reserved */
+#define OCDFMTDEF_CONTAINER_48BIT (5 << OCDFMTDEF_CONTAINER_SHIFT)
+/* 6 (0x00C000) reserved */
+#define OCDFMTDEF_CONTAINER_64BIT (7 << OCDFMTDEF_CONTAINER_SHIFT)
+
+/**** Bits 0-5 contain the total number of component bits minus one. ****/
+/* To calculate the number of bits for each RGBA component, use the following
+ * formula:
+ *
+ * green bits = int((color bits + 2) / 3)
+ * blue bits = int((color bits - green bits) / 2)
+ * red bits = color bits - green bits - blue bits
+ * alpha bits (when present) = container size - color bits
+ *
+ * Ex. 1:  RGB16 -> 16 bits
+ *	   green bits = int((16 + 2) / 3) = 6
+ *         blue bits = int((16 - 6) / 2) = 5
+ *         red bits = 16 - 6 - 5 = 5
+ *         alpha bits = n/a
+ * Ex. 2:  ARGB16 -> 16 bits
+ *	   green bits = int((16 + 2) / 3) = 6
+ *         blue bits = int((16 - 6) / 2) = 5
+ *         red bits = 16 - 6 - 5 = 5
+ *         alpha bits = 24 - 16 = 8
+ * Ex. 3:  RGB32 -> 32 bits
+ *	   green bits = int((32 + 2) / 3) = 11
+ *	   blue bits = int((32 - 11) / 2) = 10
+ *	   red bits = 32 - 11 - 10 = 11
+ *	   alpha bits = n/a
+ *
+ * For planar formats, the container indicates the total number of bits on the
+ * subsampled boundary, while the component bits are the average number of
+ * bits per pixel.
+ *
+ * Ex. 1:  YV12 -> YCbCr 4:2:0 w/8-bit samples -> 4x8 + 2x8 = 48 bit container
+ *	   48 bits / 4 pixels = 12 bpp
+ * Ex. 2:  NV16 -> YCbCr 4:2:2 w/8-bit samples -> 2x8 + 2x8 = 32 bit container
+ *	   24 bits / 2 pixels = 16 bpp
+ */
+#define OCDFMTDEF_COMPONENTSIZEMINUS1_SHIFT 0
+#define OCDFMTDEF_COMPONENTSIZEMINUS1_MASK \
+	(0x3F << OCDFMTDEF_COMPONENTSIZEMINUS1_SHIFT)
+
+
+/*
+ * The formats below are constructed from the definitions above.  However, not
+ * all formats possible are specified (and named) below.  The other formats
+ * which can be uniquely formed using the above definitions are legitimate
+ * formats, and may be used as well.
+ */
+enum ocdformat {
+	OCDFMT_UNKNOWN = -1,
+	OCDFMT_NONE = OCDFMT_UNKNOWN,
+
+ /*** Alpha only ***/
+ /** Packed **/
+	OCDFMT_ALPHA1 =	OCDFMTDEF_VENDOR_ALL |
+			OCDFMTDEF_CS_ALPHA |
+			OCDFMTDEF_ALPHA_COMPONENTS_1 |
+			OCDFMTDEF_PACKED |
+			OCDFMTDEF_CONTAINER_8BIT |
+			(1 - 1),
+	OCDFMT_ALPHA2 =	OCDFMTDEF_VENDOR_ALL |
+			OCDFMTDEF_CS_ALPHA |
+			OCDFMTDEF_ALPHA_COMPONENTS_1 |
+			OCDFMTDEF_PACKED |
+			OCDFMTDEF_CONTAINER_8BIT |
+			(2 - 1),
+	OCDFMT_ALPHA4 =	OCDFMTDEF_VENDOR_ALL |
+			OCDFMTDEF_CS_ALPHA |
+			OCDFMTDEF_ALPHA_COMPONENTS_1 |
+			OCDFMTDEF_PACKED |
+			OCDFMTDEF_CONTAINER_8BIT |
+			(4 - 1),
+	OCDFMT_ALPHA8 =	OCDFMTDEF_VENDOR_ALL |
+			OCDFMTDEF_CS_ALPHA |
+			OCDFMTDEF_ALPHA_COMPONENTS_1 |
+			OCDFMTDEF_PACKED |
+			OCDFMTDEF_CONTAINER_8BIT |
+			(8 - 1),
+ /* Sub-pixel */
+	OCDFMT_ALPHA4x1 = OCDFMTDEF_VENDOR_ALL |
+			OCDFMTDEF_CS_ALPHA |
+			OCDFMTDEF_ALPHA_COMPONENTS_4 |
+			OCDFMTDEF_PACKED |
+			OCDFMTDEF_CONTAINER_8BIT |
+			(4 - 1),
+	OCDFMT_ALPHA3x8 = OCDFMTDEF_VENDOR_ALL |
+			OCDFMTDEF_CS_ALPHA |
+			OCDFMTDEF_ALPHA_COMPONENTS_3 |
+			OCDFMTDEF_PACKED |
+			OCDFMTDEF_CONTAINER_24BIT |
+			(24 - 1),
+	OCDFMT_ALPHA4x8 = OCDFMTDEF_VENDOR_ALL |
+			OCDFMTDEF_CS_ALPHA |
+			OCDFMTDEF_ALPHA_COMPONENTS_4 |
+			OCDFMTDEF_PACKED |
+			OCDFMTDEF_CONTAINER_32BIT |
+			(32 - 1),
+
+ /*** Monochrome ***/
+ /** Packed **/
+	OCDFMT_MONO1 =	OCDFMTDEF_VENDOR_ALL |
+			OCDFMTDEF_CS_MONO |
+			OCDFMTDEF_PACKED |
+			OCDFMTDEF_CONTAINER_8BIT |
+			(1 - 1),
+	OCDFMT_MONO2 =	OCDFMTDEF_VENDOR_ALL |
+			OCDFMTDEF_CS_MONO |
+			OCDFMTDEF_PACKED |
+			OCDFMTDEF_CONTAINER_8BIT |
+			(2 - 1),
+	OCDFMT_MONO4 =	OCDFMTDEF_VENDOR_ALL |
+			OCDFMTDEF_CS_MONO |
+			OCDFMTDEF_PACKED |
+			OCDFMTDEF_CONTAINER_8BIT |
+			(4 - 1),
+	OCDFMT_MONO8 =	OCDFMTDEF_VENDOR_ALL |
+			OCDFMTDEF_CS_MONO |
+			OCDFMTDEF_PACKED |
+			OCDFMTDEF_CONTAINER_8BIT |
+			(8 - 1),
+
+  /*** Palettized (look-up-table) ***/
+  /** Packed **/
+	OCDFMT_LUT1 =	OCDFMTDEF_VENDOR_ALL |
+			OCDFMTDEF_CS_LUT |
+			OCDFMTDEF_PACKED |
+			OCDFMTDEF_CONTAINER_8BIT |
+			(1 - 1),
+	OCDFMT_LUT2 =	OCDFMTDEF_VENDOR_ALL |
+			OCDFMTDEF_CS_LUT |
+			OCDFMTDEF_PACKED |
+			OCDFMTDEF_CONTAINER_8BIT |
+			(2 - 1),
+	OCDFMT_LUT4 =	OCDFMTDEF_VENDOR_ALL |
+			OCDFMTDEF_CS_LUT |
+			OCDFMTDEF_PACKED |
+			OCDFMTDEF_CONTAINER_8BIT |
+			(4 - 1),
+	OCDFMT_LUT8 =	OCDFMTDEF_VENDOR_ALL |
+			OCDFMTDEF_CS_LUT |
+			OCDFMTDEF_PACKED |
+			OCDFMTDEF_CONTAINER_8BIT |
+			(8 - 1),
+
+ /*** RGB ***/
+ /** Packed **/
+ /* No subsampling */
+	OCDFMT_RGB12 =	OCDFMTDEF_VENDOR_ALL |
+			OCDFMTDEF_CS_RGB |
+			OCDFMTDEF_SUBSAMPLE_NONE |
+			OCDFMTDEF_PACKED |
+			OCDFMTDEF_CONTAINER_16BIT |
+			(12 - 1),			/* (15):4:4:4 */
+	OCDFMT_xRGB12 =	OCDFMT_RGB12,
+	OCDFMT_1RGB12 =	OCDFMT_xRGB12,
+	OCDFMT_0RGB12 =	OCDFMT_xRGB12 |
+			OCDFMTDEF_FILL_EMPTY_0,		/* (0):4:4:4 */
+
+	OCDFMT_BGR12 =	OCDFMT_RGB12 |
+			OCDFMTDEF_REVERSED,		/* (15):4:4:4 */
+	OCDFMT_xBGR12 =	OCDFMT_BGR12,
+	OCDFMT_1BGR12 =	OCDFMT_xBGR12,
+	OCDFMT_0BGR12 =	OCDFMT_xBGR12 |
+			OCDFMTDEF_FILL_EMPTY_0,		/* (0):4:4:4 */
+
+	OCDFMT_RGBx12 =	OCDFMT_xRGB12 |
+			OCDFMTDEF_LEFT_JUSTIFIED,	/* 4:4:4:(15) */
+	OCDFMT_RGB112 =	OCDFMT_RGBx12,
+	OCDFMT_RGB012 =	OCDFMT_RGBx12 |
+			OCDFMTDEF_FILL_EMPTY_0,		/* 4:4:4:(0) */
+
+	OCDFMT_BGRx12 =	OCDFMT_xRGB12 |
+			OCDFMTDEF_LEFT_JUSTIFIED |
+			OCDFMTDEF_REVERSED,		/* 4:4:4:(15) */
+	OCDFMT_BGR112 =	OCDFMT_BGRx12,
+	OCDFMT_BGR012 =	OCDFMT_BGRx12 |
+			OCDFMTDEF_FILL_EMPTY_0,		/* 4:4:4:(0) */
+
+	OCDFMT_RGB15 =	OCDFMTDEF_VENDOR_ALL |
+			OCDFMTDEF_CS_RGB |
+			OCDFMTDEF_SUBSAMPLE_NONE |
+			OCDFMTDEF_PACKED |
+			OCDFMTDEF_CONTAINER_16BIT |
+			(15 - 1),			/* (1):5:5:5 */
+	OCDFMT_xRGB15 =	OCDFMT_RGB15,
+	OCDFMT_1RGB15 =	OCDFMT_xRGB15,
+	OCDFMT_0RGB15 =	OCDFMT_xRGB15 |
+			OCDFMTDEF_FILL_EMPTY_0,		/* (0):5:5:5 */
+
+	OCDFMT_BGR15 =	OCDFMT_RGB15 |
+			OCDFMTDEF_REVERSED,		/* (1):5:5:5 */
+	OCDFMT_xBGR15 =	OCDFMT_BGR15,
+	OCDFMT_1BGR15 =	OCDFMT_xBGR15,
+	OCDFMT_0BGR15 =	OCDFMT_xBGR15 |
+			OCDFMTDEF_FILL_EMPTY_0,		/* (0):5:5:5 */
+
+	OCDFMT_RGBx15 =	OCDFMT_RGB15 |
+			OCDFMTDEF_LEFT_JUSTIFIED,	/* 5:5:5:(1) */
+	OCDFMT_RGB115 =	OCDFMT_RGBx15,
+	OCDFMT_RGB015 =	OCDFMT_RGBx15 |
+			OCDFMTDEF_FILL_EMPTY_0,		/* 5:5:5:(0) */
+
+	OCDFMT_BGRx15 =	OCDFMT_RGB15 |
+			OCDFMTDEF_LEFT_JUSTIFIED |
+			OCDFMTDEF_REVERSED,		/* 5:5:5:(1) */
+	OCDFMT_BGR115 =	OCDFMT_BGRx15,
+	OCDFMT_BGR015 =	OCDFMT_BGRx15 |
+			OCDFMTDEF_FILL_EMPTY_0,		/* 5:5:5:(0) */
+
+	OCDFMT_RGB16 =	OCDFMTDEF_VENDOR_ALL |
+			OCDFMTDEF_CS_RGB |
+			OCDFMTDEF_SUBSAMPLE_NONE |
+			OCDFMTDEF_PACKED |
+			OCDFMTDEF_CONTAINER_16BIT |
+			(16 - 1),			/* 5:6:5 */
+	OCDFMT_BGR16 =	OCDFMT_RGB16 |
+			OCDFMTDEF_REVERSED,		/* 5:6:5 */
+
+	OCDFMT_RGB24 =	OCDFMTDEF_VENDOR_ALL |
+			OCDFMTDEF_CS_RGB |
+			OCDFMTDEF_SUBSAMPLE_NONE |
+			OCDFMTDEF_PACKED |
+			OCDFMTDEF_CONTAINER_24BIT |
+			(24 - 1),			/* 8:8:8 */
+	OCDFMT_BGR24 =	OCDFMT_RGB24 |
+			OCDFMTDEF_REVERSED,		/* 8:8:8 */
+
+	OCDFMT_xRGB16 =	OCDFMTDEF_VENDOR_ALL |
+			OCDFMTDEF_CS_RGB |
+			OCDFMTDEF_SUBSAMPLE_NONE |
+			OCDFMTDEF_PACKED |
+			OCDFMTDEF_CONTAINER_24BIT |
+			(16 - 1),			/* (255):5:6:5 */
+	OCDFMT_1RGB16 =	OCDFMT_xRGB16,
+	OCDFMT_0RGB16 =	OCDFMT_xRGB16  |
+			OCDFMTDEF_FILL_EMPTY_0,		/* (0):5:6:5 */
+
+	OCDFMT_xBGR16 =	OCDFMT_xRGB16 |
+			OCDFMTDEF_REVERSED,		/* (255):5:6:5 */
+	OCDFMT_1BGR16 =	OCDFMT_xBGR16,
+	OCDFMT_0BGR16 =	OCDFMT_xBGR16  |
+			OCDFMTDEF_FILL_EMPTY_0,		/* (0):5:6:5 */
+
+	OCDFMT_RGBx16 =	OCDFMT_xRGB16 |
+			OCDFMTDEF_LEFT_JUSTIFIED,	/* 5:6:5:(255) */
+	OCDFMT_RGB116 =	OCDFMT_RGBx16,
+	OCDFMT_RGB016 =	OCDFMT_RGBx16  |
+			OCDFMTDEF_FILL_EMPTY_0,		/* 5:6:5:(0) */
+
+	OCDFMT_BGRx16 =	OCDFMT_xRGB16 |
+			OCDFMTDEF_LEFT_JUSTIFIED |
+			OCDFMTDEF_REVERSED,		/* 5:6:5:(255) */
+	OCDFMT_BGR116 =	OCDFMT_BGRx16,
+	OCDFMT_BGR016 =	OCDFMT_BGRx16  |
+			OCDFMTDEF_FILL_EMPTY_0,		/* 5:6:5:(0) */
+
+	OCDFMT_xRGB24 =	OCDFMTDEF_VENDOR_ALL |
+			OCDFMTDEF_CS_RGB |
+			OCDFMTDEF_SUBSAMPLE_NONE |
+			OCDFMTDEF_PACKED |
+			OCDFMTDEF_CONTAINER_32BIT |
+			(24 - 1),			/* (255):8:8:8 */
+	OCDFMT_1RGB24 =	OCDFMT_xRGB24,
+	OCDFMT_0RGB24 =	OCDFMT_xRGB24 |
+			OCDFMTDEF_FILL_EMPTY_0,		/* (0):8:8:8 */
+
+	OCDFMT_xBGR24 =	OCDFMT_xRGB24 |
+			OCDFMTDEF_REVERSED,		/* (255):8:8:8 */
+	OCDFMT_1BGR24 =	OCDFMT_xBGR24,
+	OCDFMT_0BGR24 =	OCDFMT_xBGR24 |
+			OCDFMTDEF_FILL_EMPTY_0,		/* (0):8:8:8 */
+
+	OCDFMT_RGBx24 =	OCDFMT_xRGB24 |
+			OCDFMTDEF_LEFT_JUSTIFIED,	/* 8:8:8:(255) */
+	OCDFMT_RGB124 =	OCDFMT_RGBx24,
+	OCDFMT_RGB024 =	OCDFMT_RGBx24 |
+			OCDFMTDEF_FILL_EMPTY_0,		/* 8:8:8:(0) */
+
+	OCDFMT_BGRx24 =	OCDFMT_xRGB24 |
+			OCDFMTDEF_LEFT_JUSTIFIED |
+			OCDFMTDEF_REVERSED,		/* 8:8:8:(255) */
+	OCDFMT_BGR124 =	OCDFMT_BGRx24,
+	OCDFMT_BGR024 =	OCDFMT_BGRx24 |
+			OCDFMTDEF_FILL_EMPTY_0,		/* 8:8:8:(0) */
+
+  /* Premultiplied ARGB */
+	OCDFMT_ARGB12 =	OCDFMT_xRGB12 |
+			OCDFMTDEF_ALPHA,		/* 4:4:4:4 */
+	OCDFMT_ABGR12 =	OCDFMT_xBGR12 |
+			OCDFMTDEF_ALPHA,		/* 4:4:4:4 */
+	OCDFMT_RGBA12 =	OCDFMT_RGBx12 |
+			OCDFMTDEF_ALPHA,		/* 4:4:4:4 */
+	OCDFMT_BGRA12 =	OCDFMT_BGRx12 |
+			OCDFMTDEF_ALPHA,		/* 4:4:4:4 */
+
+	OCDFMT_ARGB16 =	OCDFMT_xRGB16 |
+			OCDFMTDEF_ALPHA,		/* 8:5:6:5 */
+	OCDFMT_ABGR16 =	OCDFMT_ARGB16 |
+			OCDFMTDEF_REVERSED,		/* 8:5:6:5 */
+	OCDFMT_RGBA16 =	OCDFMT_ARGB16 |
+			OCDFMTDEF_LEFT_JUSTIFIED,	/* 5:6:5:8 */
+	OCDFMT_BGRA16 =	OCDFMT_ARGB16 |
+			OCDFMTDEF_LEFT_JUSTIFIED |
+			OCDFMTDEF_REVERSED,		/* 5:6:5:8 */
+
+	OCDFMT_ARGB24 =	OCDFMT_xRGB24 |
+			OCDFMTDEF_ALPHA,		/* 8:8:8:8 */
+	OCDFMT_ABGR24 =	OCDFMT_xBGR24 |
+			OCDFMTDEF_ALPHA,		/* 8:8:8:8 */
+	OCDFMT_RGBA24 =	OCDFMT_RGBx24 |
+			OCDFMTDEF_ALPHA,		/* 8:8:8:8 */
+	OCDFMT_BGRA24 =	OCDFMT_BGRx24 |
+			OCDFMTDEF_ALPHA,		/* 8:8:8:8 */
+
+  /* Non-premultiplied ARGB */
+	OCDFMT_nARGB12 =	OCDFMT_ARGB12 |
+			OCDFMTDEF_NON_PREMULT,
+	OCDFMT_ARGB12_NON_PREMULT = OCDFMT_nARGB12,
+
+	OCDFMT_nABGR12 =	OCDFMT_ABGR12 |
+			OCDFMTDEF_NON_PREMULT,
+	OCDFMT_ABGR12_NON_PREMULT = OCDFMT_nABGR12,
+
+	OCDFMT_nRGBA12 =	OCDFMT_RGBA12 |
+			OCDFMTDEF_NON_PREMULT,
+	OCDFMT_RGBA12_NON_PREMULT = OCDFMT_nRGBA12,
+
+	OCDFMT_nBGRA12 =	OCDFMT_BGRA12 |
+			OCDFMTDEF_NON_PREMULT,
+	OCDFMT_BGRA12_NON_PREMULT = OCDFMT_nBGRA12,
+
+	OCDFMT_ARGB15 =	OCDFMTDEF_VENDOR_ALL |
+			OCDFMTDEF_CS_RGB |
+			OCDFMTDEF_ALPHA |
+			OCDFMTDEF_NON_PREMULT |
+			OCDFMTDEF_SUBSAMPLE_NONE |
+			OCDFMTDEF_PACKED |
+			OCDFMTDEF_CONTAINER_16BIT |
+			(15 - 1),			/* 1:5:5:5 - "normal"
+							   format is not
+							   premultiplied */
+	OCDFMT_nARGB15 =	OCDFMT_ARGB15,
+	OCDFMT_ARGB15_NON_PREMULT = OCDFMT_nARGB15,
+
+	OCDFMT_ABGR15 =	OCDFMT_ARGB15 |
+			OCDFMTDEF_REVERSED,		/* 1:5:5:5 - "normal"
+							   format is not
+							   premultiplied */
+	OCDFMT_nABGR15 =	OCDFMT_ABGR15,
+	OCDFMT_ABGR15_NON_PREMULT = OCDFMT_nABGR15,
+
+	OCDFMT_RGBA15 =	OCDFMT_ARGB15 |
+			OCDFMTDEF_LEFT_JUSTIFIED,	/* 5:5:5:1 - "normal"
+							   format is not
+							   premultiplied */
+	OCDFMT_nRGBA15 =	OCDFMT_RGBA15,
+	OCDFMT_RGBA15_NON_PREMULT = OCDFMT_nRGBA15,
+
+	OCDFMT_BGRA15 =	OCDFMT_ARGB15 |
+			OCDFMTDEF_LEFT_JUSTIFIED |
+			OCDFMTDEF_REVERSED,		/* 5:5:5:1 - "normal"
+							   format is not
+							   premultiplied */
+	OCDFMT_nBGRA15 =	OCDFMT_BGRA15,
+	OCDFMT_BGRA15_NON_PREMULT = OCDFMT_nRGBA15,
+
+	OCDFMT_nARGB16 =	OCDFMT_ARGB16 |
+			OCDFMTDEF_NON_PREMULT,
+	OCDFMT_ARGB16_NON_PREMULT = OCDFMT_nARGB16,
+
+	OCDFMT_nABGR16 =	OCDFMT_ABGR16 |
+			OCDFMTDEF_NON_PREMULT,
+	OCDFMT_ABGR16_NON_PREMULT =	OCDFMT_nABGR16,
+
+	OCDFMT_nRGBA16 =	OCDFMT_RGBA16 |
+			OCDFMTDEF_NON_PREMULT,
+	OCDFMT_RGBA16_NON_PREMULT = OCDFMT_nRGBA16,
+
+	OCDFMT_nBGRA16 = OCDFMT_BGRA16 |
+			OCDFMTDEF_NON_PREMULT,
+	OCDFMT_BGRA16_NON_PREMULT = OCDFMT_nBGRA16,
+
+	OCDFMT_nARGB24 =	OCDFMT_ARGB24 |
+			OCDFMTDEF_NON_PREMULT,
+	OCDFMT_ARGB24_NON_PREMULT = OCDFMT_nARGB24,
+
+	OCDFMT_nABGR24 =	OCDFMT_ABGR24 |
+			OCDFMTDEF_NON_PREMULT,
+	OCDFMT_ABGR24_NON_PREMULT = OCDFMT_nABGR24,
+
+	OCDFMT_nRGBA24 =	OCDFMT_RGBA24 |
+			OCDFMTDEF_NON_PREMULT,
+	OCDFMT_RGBA24_NON_PREMULT = OCDFMT_nRGBA24,
+
+	OCDFMT_nBGRA24 =	OCDFMT_BGRA24 |
+			OCDFMTDEF_NON_PREMULT,
+	OCDFMT_BGRA24_NON_PREMULT = OCDFMT_nBGRA24,
+
+  /*** YCbCr ***/
+  /** Packed **/
+  /* YCbCr 4:2:2 */
+	OCDFMT_UYVY =	OCDFMTDEF_VENDOR_ALL |
+			OCDFMTDEF_CS_YCbCr |
+			OCDFMTDEF_SUBSAMPLE_422_YCbCr |
+			OCDFMTDEF_SUBSAMPLE_HORZ_ALIGNED |
+			OCDFMTDEF_PACKED |
+			OCDFMTDEF_CONTAINER_32BIT |
+			(16 - 1),
+	OCDFMT_UYVY_601 = OCDFMT_UYVY |
+			OCDFMTDEF_STD_ITUR_601_YCbCr,
+	OCDFMT_UYVY_709 = OCDFMT_UYVY |
+			OCDFMTDEF_STD_ITUR_709_YCbCr,
+	OCDFMT_Y422 = OCDFMT_UYVY,
+	OCDFMT_Y422_601 = OCDFMT_UYVY_601,
+	OCDFMT_Y422_709 = OCDFMT_UYVY_709,
+
+	OCDFMT_VYUY =	OCDFMT_UYVY |
+			OCDFMTDEF_REVERSED,
+	OCDFMT_VYUY_601 = OCDFMT_VYUY |
+			OCDFMTDEF_STD_ITUR_601_YCbCr,
+	OCDFMT_VYUY_709 = OCDFMT_VYUY |
+			OCDFMTDEF_STD_ITUR_709_YCbCr,
+
+	OCDFMT_YUYV =	OCDFMT_UYVY |
+			OCDFMTDEF_LEFT_JUSTIFIED,
+	OCDFMT_YUYV_601 = OCDFMT_YUYV |
+			OCDFMTDEF_STD_ITUR_601_YCbCr,
+	OCDFMT_YUYV_709 = OCDFMT_YUYV |
+			OCDFMTDEF_STD_ITUR_709_YCbCr,
+	OCDFMT_YUY2 = OCDFMT_YUYV,
+	OCDFMT_YUY2_601 = OCDFMT_YUYV_601,
+	OCDFMT_YUY2_709 = OCDFMT_YUYV_709,
+
+	OCDFMT_YVYU =	OCDFMT_VYUY |
+			OCDFMTDEF_LEFT_JUSTIFIED,
+	OCDFMT_YVYU_601 = OCDFMT_YVYU |
+			OCDFMTDEF_STD_ITUR_601_YCbCr,
+	OCDFMT_YVYU_709 = OCDFMT_YVYU |
+			OCDFMTDEF_STD_ITUR_709_YCbCr,
+
+  /** 3-plane **/
+  /* YCbCr 4:2:2 */
+	OCDFMT_YV16 =	OCDFMTDEF_VENDOR_ALL |
+			OCDFMTDEF_CS_YCbCr |
+			OCDFMTDEF_SUBSAMPLE_422_YCbCr |
+			OCDFMTDEF_SUBSAMPLE_HORZ_ALIGNED |
+			OCDFMTDEF_3_PLANE_STACKED |
+			OCDFMTDEF_CONTAINER_32BIT |
+			(16 - 1),
+	OCDFMT_YV16_601 = OCDFMT_YV16 |
+			OCDFMTDEF_STD_ITUR_601_YCbCr,
+	OCDFMT_YV16_709 = OCDFMT_YV16 |
+			OCDFMTDEF_STD_ITUR_709_YCbCr,
+
+  /* YCbCr 4:2:0 */
+	OCDFMT_IYUV =	OCDFMTDEF_VENDOR_ALL |
+			OCDFMTDEF_CS_YCbCr |
+			OCDFMTDEF_SUBSAMPLE_420_YCbCr |
+			OCDFMTDEF_SUBSAMPLE_HORZ_ALIGNED |
+			OCDFMTDEF_3_PLANE_STACKED |
+			OCDFMTDEF_CONTAINER_48BIT |
+			(12 - 1),
+	OCDFMT_IYUV_601 = OCDFMT_IYUV |
+			OCDFMTDEF_STD_ITUR_601_YCbCr,
+	OCDFMT_IYUV_709 = OCDFMT_IYUV |
+			OCDFMTDEF_STD_ITUR_709_YCbCr,
+	OCDFMT_I420 = OCDFMT_IYUV,
+	OCDFMT_I420_601 = OCDFMT_IYUV_601,
+	OCDFMT_I420_709 = OCDFMT_IYUV_709,
+
+	OCDFMT_YV12 =	OCDFMT_IYUV |
+			OCDFMTDEF_REVERSED,
+	OCDFMT_YV12_601 = OCDFMT_YV12 |
+			OCDFMTDEF_STD_ITUR_601_YCbCr,
+	OCDFMT_YV12_709 = OCDFMT_YV12 |
+			OCDFMTDEF_STD_ITUR_709_YCbCr,
+
+	OCDFMT_IMC3 =	OCDFMTDEF_VENDOR_ALL |
+			OCDFMTDEF_CS_YCbCr |
+			OCDFMTDEF_SUBSAMPLE_420_YCbCr |
+			OCDFMTDEF_SUBSAMPLE_HORZ_ALIGNED |
+			OCDFMTDEF_3_PLANE_STACKED |
+			OCDFMTDEF_LEFT_JUSTIFIED |	/* Indicates wasted
+							   space to the
+							   right */
+			OCDFMTDEF_CONTAINER_48BIT |
+			(12 - 1),
+	OCDFMT_IMC3_601 = OCDFMT_IMC3 |
+			OCDFMTDEF_STD_ITUR_601_YCbCr,
+	OCDFMT_IMC3_709 = OCDFMT_IMC3 |
+			OCDFMTDEF_STD_ITUR_709_YCbCr,
+
+	OCDFMT_IMC1 =	OCDFMT_IMC3 |
+			OCDFMTDEF_REVERSED,
+	OCDFMT_IMC1_601 = OCDFMT_IMC1 |
+			OCDFMTDEF_STD_ITUR_601_YCbCr,
+	OCDFMT_IMC1_709 = OCDFMT_IMC1 |
+			OCDFMTDEF_STD_ITUR_709_YCbCr,
+
+	OCDFMT_IMC4 =	OCDFMTDEF_VENDOR_ALL |
+			OCDFMTDEF_CS_YCbCr |
+			OCDFMTDEF_STD_ITUR_601_YCbCr |
+			OCDFMTDEF_SUBSAMPLE_420_YCbCr |
+			OCDFMTDEF_SUBSAMPLE_HORZ_ALIGNED |
+			OCDFMTDEF_3_PLANE_SIDE_BY_SIDE_YCbCr |
+			OCDFMTDEF_CONTAINER_48BIT |
+			(12 - 1),
+	OCDFMT_IMC4_601 = OCDFMT_IMC4 |
+			OCDFMTDEF_STD_ITUR_601_YCbCr,
+	OCDFMT_IMC4_709 = OCDFMT_IMC4 |
+			OCDFMTDEF_STD_ITUR_709_YCbCr,
+
+	OCDFMT_IMC2 =	OCDFMT_IMC4 |
+			OCDFMTDEF_REVERSED,
+	OCDFMT_IMC2_601 = OCDFMT_IMC2 |
+			OCDFMTDEF_STD_ITUR_601_YCbCr,
+	OCDFMT_IMC2_709 = OCDFMT_IMC2 |
+			OCDFMTDEF_STD_ITUR_709_YCbCr,
+
+  /** 2-plane **/
+  /* YCbCr 4:2:2 */
+	OCDFMT_NV16 =	OCDFMTDEF_VENDOR_ALL |
+			OCDFMTDEF_CS_YCbCr |
+			OCDFMTDEF_SUBSAMPLE_422_YCbCr |
+			OCDFMTDEF_SUBSAMPLE_HORZ_ALIGNED |
+			OCDFMTDEF_2_PLANE_YCbCr |
+			OCDFMTDEF_CONTAINER_32BIT |
+			(16 - 1),
+	OCDFMT_NV16_601 = OCDFMT_NV16 |
+			OCDFMTDEF_STD_ITUR_601_YCbCr,
+	OCDFMT_NV16_709 = OCDFMT_NV16 |
+			OCDFMTDEF_STD_ITUR_709_YCbCr,
+
+	OCDFMT_NV61 =	OCDFMT_NV16 |
+			OCDFMTDEF_REVERSED,
+	OCDFMT_NV61_601 = OCDFMT_NV61 |
+			OCDFMTDEF_STD_ITUR_601_YCbCr,
+	OCDFMT_NV61_709 = OCDFMT_NV61 |
+			OCDFMTDEF_STD_ITUR_709_YCbCr,
+
+  /* YCbCr 4:2:0 */
+	OCDFMT_NV12 =	OCDFMTDEF_VENDOR_ALL |
+			OCDFMTDEF_CS_YCbCr |
+			OCDFMTDEF_STD_ITUR_601_YCbCr |
+			OCDFMTDEF_SUBSAMPLE_420_YCbCr |
+			OCDFMTDEF_SUBSAMPLE_HORZ_ALIGNED |
+			OCDFMTDEF_2_PLANE_YCbCr |
+			OCDFMTDEF_CONTAINER_48BIT |
+			(12 - 1),
+	OCDFMT_NV12_601 = OCDFMT_NV12 |
+			OCDFMTDEF_STD_ITUR_601_YCbCr,
+	OCDFMT_NV12_709 = OCDFMT_NV12 |
+			OCDFMTDEF_STD_ITUR_709_YCbCr,
+
+	OCDFMT_NV21 =	OCDFMT_NV12 |
+			OCDFMTDEF_REVERSED,
+	OCDFMT_NV21_601 = OCDFMT_NV21 |
+			OCDFMTDEF_STD_ITUR_601_YCbCr,
+	OCDFMT_NV21_709 = OCDFMT_NV21 |
+			OCDFMTDEF_STD_ITUR_709_YCbCr,
+
+#ifdef OCD_EXTERNAL_INCLUDE
+#include OCD_EXTERNAL_INCLUDE
+#endif
+};
+
+#endif /* OCD_H */
diff --git a/include/video/dsscomp.h b/include/video/dsscomp.h
new file mode 100644
index 0000000..147c8a2
--- /dev/null
+++ b/include/video/dsscomp.h
@@ -0,0 +1,646 @@
+#ifndef _LINUX_DSSCOMP_H
+#define _LINUX_DSSCOMP_H
+
+#ifdef __KERNEL__
+#include <video/omapdss.h>
+#else
+
+/* exporting enumerations from arch/arm/plat-omap/include/plat/display.h */
+enum omap_plane {
+	OMAP_DSS_GFX	= 0,
+	OMAP_DSS_VIDEO1	= 1,
+	OMAP_DSS_VIDEO2	= 2,
+	OMAP_DSS_VIDEO3	= 3,
+	OMAP_DSS_WB		= 4,
+};
+
+enum omap_channel {
+	OMAP_DSS_CHANNEL_LCD	= 0,
+	OMAP_DSS_CHANNEL_DIGIT	= 1,
+	OMAP_DSS_CHANNEL_LCD2	= 2,
+};
+
+enum omap_color_mode {
+	OMAP_DSS_COLOR_CLUT1		= 1 << 0,  /* BITMAP 1 */
+	OMAP_DSS_COLOR_CLUT2		= 1 << 1,  /* BITMAP 2 */
+	OMAP_DSS_COLOR_CLUT4		= 1 << 2,  /* BITMAP 4 */
+	OMAP_DSS_COLOR_CLUT8		= 1 << 3,  /* BITMAP 8 */
+
+	/* also referred to as RGB 12-BPP, 16-bit container  */
+	OMAP_DSS_COLOR_RGB12U		= 1 << 4,  /* xRGB12-4444 */
+	OMAP_DSS_COLOR_ARGB16		= 1 << 5,  /* ARGB16-4444 */
+	OMAP_DSS_COLOR_RGB16		= 1 << 6,  /* RGB16-565 */
+
+	/* also referred to as RGB 24-BPP, 32-bit container */
+	OMAP_DSS_COLOR_RGB24U		= 1 << 7,  /* xRGB24-8888 */
+	OMAP_DSS_COLOR_RGB24P		= 1 << 8,  /* RGB24-888 */
+	OMAP_DSS_COLOR_YUV2		= 1 << 9,  /* YUV2 4:2:2 co-sited */
+	OMAP_DSS_COLOR_UYVY		= 1 << 10, /* UYVY 4:2:2 co-sited */
+	OMAP_DSS_COLOR_ARGB32		= 1 << 11, /* ARGB32-8888 */
+	OMAP_DSS_COLOR_RGBA32		= 1 << 12, /* RGBA32-8888 */
+
+	/* also referred to as RGBx 32 in TRM */
+	OMAP_DSS_COLOR_RGBX24		= 1 << 13, /* RGBx32-8888 */
+	OMAP_DSS_COLOR_RGBX32		= 1 << 13, /* RGBx32-8888 */
+	OMAP_DSS_COLOR_NV12		= 1 << 14, /* NV12 format: YUV 4:2:0 */
+
+	/* also referred to as RGBA12-4444 in TRM */
+	OMAP_DSS_COLOR_RGBA16		= 1 << 15, /* RGBA16-4444 */
+
+	OMAP_DSS_COLOR_RGBX12		= 1 << 16, /* RGBx16-4444 */
+	OMAP_DSS_COLOR_RGBX16		= 1 << 16, /* RGBx16-4444 */
+	OMAP_DSS_COLOR_ARGB16_1555	= 1 << 17, /* ARGB16-1555 */
+
+	/* also referred to as xRGB16-555 in TRM */
+	OMAP_DSS_COLOR_XRGB15		= 1 << 18, /* xRGB16-1555 */
+	OMAP_DSS_COLOR_XRGB16_1555	= 1 << 18, /* xRGB16-1555 */
+};
+
+enum omap_dss_trans_key_type {
+	OMAP_DSS_COLOR_KEY_GFX_DST = 0,
+	OMAP_DSS_COLOR_KEY_VID_SRC = 1,
+};
+
+enum omap_dss_display_state {
+	OMAP_DSS_DISPLAY_DISABLED = 0,
+	OMAP_DSS_DISPLAY_ACTIVE,
+	OMAP_DSS_DISPLAY_SUSPENDED,
+	OMAP_DSS_DISPLAY_TRANSITION,
+};
+
+struct omap_video_timings {
+	/* Unit: pixels */
+	__u16 x_res;
+	/* Unit: pixels */
+	__u16 y_res;
+	/* Unit: KHz */
+	__u32 pixel_clock;
+	/* Unit: pixel clocks */
+	__u16 hsw;	/* Horizontal synchronization pulse width */
+	/* Unit: pixel clocks */
+	__u16 hfp;	/* Horizontal front porch */
+	/* Unit: pixel clocks */
+	__u16 hbp;	/* Horizontal back porch */
+	/* Unit: line clocks */
+	__u16 vsw;	/* Vertical synchronization pulse width */
+	/* Unit: line clocks */
+	__u16 vfp;	/* Vertical front porch */
+	/* Unit: line clocks */
+	__u16 vbp;	/* Vertical back porch */
+};
+
+struct omap_dss_cpr_coefs {
+	__s16 rr, rg, rb;
+	__s16 gr, gg, gb;
+	__s16 br, bg, bb;
+};
+
+/*
+ * Stereoscopic Panel types
+ * row, column, overunder, sidebyside options
+ * are with respect to native scan order
+ */
+enum s3d_disp_type {
+	S3D_DISP_NONE = 0,
+	S3D_DISP_FRAME_SEQ,
+	S3D_DISP_ROW_IL,
+	S3D_DISP_COL_IL,
+	S3D_DISP_PIX_IL,
+	S3D_DISP_CHECKB,
+	S3D_DISP_OVERUNDER,
+	S3D_DISP_SIDEBYSIDE,
+};
+
+/* Subsampling direction is based on native panel scan order.*/
+enum s3d_disp_sub_sampling {
+	S3D_DISP_SUB_SAMPLE_NONE = 0,
+	S3D_DISP_SUB_SAMPLE_V,
+	S3D_DISP_SUB_SAMPLE_H,
+};
+
+/*
+ * Indicates if display expects left view first followed by right or viceversa
+ * For row interlaved displays, defines first row view
+ * For column interleaved displays, defines first column view
+ * For checkerboard, defines first pixel view
+ * For overunder, defines top view
+ * For sidebyside, defines west view
+ */
+enum s3d_disp_order {
+	S3D_DISP_ORDER_L = 0,
+	S3D_DISP_ORDER_R = 1,
+};
+
+/*
+ * Indicates current view
+ * Used mainly for displays that need to trigger a sync signal
+ */
+enum s3d_disp_view {
+	S3D_DISP_VIEW_L = 0,
+	S3D_DISP_VIEW_R,
+};
+
+struct s3d_disp_info {
+	enum s3d_disp_type type;
+	enum s3d_disp_sub_sampling sub_samp;
+	enum s3d_disp_order order;
+	/*
+	 * Gap between left and right views
+	 * For over/under units are lines
+	 * For sidebyside units are pixels
+	 * For other types ignored
+	 */
+	unsigned int gap;
+};
+
+#endif
+
+/* YUV to RGB color conversion info */
+struct omap_dss_cconv_coefs {
+	__s16 ry, rcr, rcb;
+	__s16 gy, gcr, gcb;
+	__s16 by, bcr, bcb;
+
+	/* Y is 16..235, UV is 16..240 if not fullrange.  Otherwise 0..255 */
+	__u16 full_range;
+} __aligned(4);
+
+
+/* copy of fb_videomode */
+struct dsscomp_videomode {
+	const char *name;	/* optional */
+	__u32 refresh;		/* optional */
+	__u32 xres;
+	__u32 yres;
+	__u32 pixclock;
+	__u32 left_margin;
+	__u32 right_margin;
+	__u32 upper_margin;
+	__u32 lower_margin;
+	__u32 hsync_len;
+	__u32 vsync_len;
+	__u32 sync;
+	__u32 vmode;
+	__u32 flag;
+};
+
+enum omap_dss_ilace_mode {
+	OMAP_DSS_ILACE		= (1 << 0),	/* interlaced vs. progressive */
+	OMAP_DSS_ILACE_SEQ	= (1 << 1),	/* sequential vs interleaved */
+	OMAP_DSS_ILACE_SWAP	= (1 << 2),	/* swap fields, e.g. TB=>BT */
+
+	OMAP_DSS_ILACE_NONE	= 0,
+	OMAP_DSS_ILACE_IL_TB	= OMAP_DSS_ILACE,
+	OMAP_DSS_ILACE_IL_BT	= OMAP_DSS_ILACE | OMAP_DSS_ILACE_SWAP,
+	OMAP_DSS_ILACE_SEQ_TB	= OMAP_DSS_ILACE_IL_TB | OMAP_DSS_ILACE_SEQ,
+	OMAP_DSS_ILACE_SEQ_BT	= OMAP_DSS_ILACE_IL_BT | OMAP_DSS_ILACE_SEQ,
+};
+
+/* YUV VC1 range mapping info */
+struct dss2_vc1_range_map_info {
+	__u8 enable;	/* bool */
+
+	__u8 range_y;	/* 0..7 */
+	__u8 range_uv;	/* 0..7 */
+} __aligned(4);
+
+/* standard rectangle */
+struct dss2_rect_t {
+	__s32 x;	/* left */
+	__s32 y;	/* top */
+	__u32 w;	/* width */
+	__u32 h;	/* height */
+} __aligned(4);
+
+/* decimation constraints */
+struct dss2_decim {
+	__u8 min_x;
+	__u8 max_x;	/* 0 is same as 255 */
+	__u8 min_y;
+	__u8 max_y;	/* 0 is same as 255 */
+} __aligned(4);
+
+/*
+ * A somewhat more user friendly interface to the DSS2.  This is a
+ * direct interface to the DSS2 overlay and overlay_manager modules.
+ * User-space APIs are provided for HW-specific control of DSS in
+ * contrast with V4L2/FB that are more generic, but in this process
+ * omit HW-specific features.
+ *
+ * For now managers are specified by display index as opposed to manager
+ * type, so that display0 is always the default display (e.g. HDMI on
+ * panda, and LCD blaze.)  For now you would need to query the displays
+ * or use sysfs to find a specific display.
+ *
+ * Userspace operations are as follows:
+ *
+ * 1) check if DSS supports an overlay configuration, use DSSCIOC_CHECK_OVL
+ * ioctl with the manager, overlay, and setup-mode information filled out.
+ * All fields should be filled out as it may influence whether DSS can
+ * display/render the overlay.
+ *
+ * If proper address information is not available, it may be possible to
+ * use a type-of-address enumeration instead for luma/rgb and chroma (if
+ * applicable) frames.
+ *
+ * Do this for each overlay before attempting to configure DSS.
+ *
+ * 2) configure DSS pipelines for display/manager using DSSCIOC_SETUP_MANAGER
+ * ioctl.  You can delay applying the settings until an dss2_manager_apply()
+ * is called for the internal composition object, if the APPLY bit of setup mode
+ * is not set.  However the CAPTURE/DISPLAY bits of the setup mode settings will
+ * determine if at this time a capture will take place (in case of capture
+ * only mode).  You may also set up additional pipelines with
+ * dss2_overlay_setup() before this.
+ *
+ * 3) On OMAP4/5 you can use the DSS WB pipeline to copy (and convert) a buffer
+ * using DSS.  Use the DSSCIOC_WB_COPY ioctl for this.  This is a blocking
+ * call, and it may possibly fail if an ongoing WB capture mode has been
+ * scheduled (which is outside of the current scope of the DSS2 interface.)
+ *
+ * There is also a one-shot configuration API (DSSCIOC_SETUP_DISPC).  This
+ * allows you to set-up all overlays on all managers in one call.  This call
+ * performs additional functionality:
+ *
+ * - it maps userspace 1D buffers into TILER 1D for the duration of the display
+ * - it disables all overlays that were specified before, but are no longer
+ *   specified
+ *
+ */
+
+/*
+ * DSS2 overlay information.  This structure contains all information
+ * needed to set up the overlay for a particular buffer to be displayed
+ * at a particular orientation.
+ *
+ * The following information is deemed to be set globally, so it is not
+ * included:
+ *   - whether to enable zorder (always enabled)
+ *   - whether to replicate/truncate color fields (it is decided per the
+ *     whole manager/overlay settings, and is enabled unless overlay is
+ *     directed to WB.)
+ *
+ * There is also no support for CLUT formats
+ *
+ * Requirements:
+ *
+ * 1) 0 <= crop.x <= crop.x + crop.w <= width
+ * 2) 0 <= crop.y <= crop.y + crop.h <= height
+ * 3) win.x <= win.x + win.w and win.w >= 0
+ * 4) win.y <= win.y + win.h and win.h >= 0
+ *
+ * 5) color_mode is supported by overlay
+ * 6) requested scaling is supported by overlay and functional clocks
+ *
+ * Notes:
+ *
+ * 1) Any portions of X:[pos_x, pos_x + out_width] and
+ *    Y:[pos_y, pos_y + out_height] outside of the screen
+ *    X:[0, screen.width], Y:[0, screen.height] will be cropped
+ *    automatically without changing the scaling ratio.
+ *
+ * 2) Crop region will be adjusted to the pixel granularity:
+ *    (2-by-1) for YUV422, (2-by-2) for YUV420.  This will
+ *    not modify the output region.  Crop region is for the
+ *    original (unrotated) buffer, so it does not change with
+ *    rotation.
+ *
+ * 3) Rotation will not modify the output region, specifically
+ *    its height and width.  Also the coordinate system of the
+ *    display is always (0,0) = top left.
+ *
+ * 4) cconv and vc1 only needs to be filled for YUV color modes.
+ *
+ * 5) vc1.range_y and vc1.range_uv only needs to be filled if
+ *    vc1.enable is true.
+ */
+struct dss2_ovl_cfg {
+	__u16 width;	/* buffer width */
+	__u16 height;	/* buffer height */
+	__u32 stride;	/* buffer stride */
+
+	enum omap_color_mode color_mode;
+	__u8 pre_mult_alpha;	/* bool */
+	__u8 global_alpha;	/* 0..255 */
+	__u8 rotation;		/* 0..3 (*90 degrees clockwise) */
+	__u8 mirror;	/* left-to-right: mirroring is applied after rotation */
+
+	enum omap_dss_ilace_mode ilace;	/* interlace mode */
+
+	struct dss2_rect_t win;		/* output window - on display */
+	struct dss2_rect_t crop;	/* crop window - in source buffer */
+
+	struct dss2_decim decim;	/* predecimation limits */
+
+	struct omap_dss_cconv_coefs cconv;
+	struct dss2_vc1_range_map_info vc1;
+
+	__u8 ix;	/* ovl index same as sysfs/overlay# */
+	__u8 zorder;	/* 0..3 */
+	__u8 enabled;	/* bool */
+	__u8 zonly;	/* only set zorder and enabled bit */
+	__u8 mgr_ix;	/* mgr index */
+} __aligned(4);
+
+enum omapdss_buffer_type {
+	OMAP_DSS_BUFTYPE_SDMA,
+	OMAP_DSS_BUFTYPE_TILER_8BIT,
+	OMAP_DSS_BUFTYPE_TILER_16BIT,
+	OMAP_DSS_BUFTYPE_TILER_32BIT,
+	OMAP_DSS_BUFTYPE_TILER_PAGE,
+};
+
+enum omapdss_buffer_addressing_type {
+	OMAP_DSS_BUFADDR_DIRECT,	/* using direct addresses */
+	OMAP_DSS_BUFADDR_BYTYPE,	/* using buffer types */
+	OMAP_DSS_BUFADDR_ION,		/* using ion handle(s) */
+	OMAP_DSS_BUFADDR_GRALLOC,	/* using gralloc handle */
+	OMAP_DSS_BUFADDR_OVL_IX,	/* using a prior overlay */
+	OMAP_DSS_BUFADDR_LAYER_IX,	/* using a Post2 layer */
+	OMAP_DSS_BUFADDR_FB,		/* using framebuffer memory */
+};
+
+struct dss2_ovl_info {
+	struct dss2_ovl_cfg cfg;
+
+	enum omapdss_buffer_addressing_type addressing;
+
+	union {
+		/* user-space interfaces */
+		struct {
+			void *address;		/* main buffer address */
+			void *uv_address;	/* uv buffer */
+		};
+
+		/*
+		 * For DSSCIOC_CHECK_OVL we allow specifying just the
+		 * type of each buffer. This is used if we need to
+		 * check whether DSS will be able to display a buffer
+		 * if using a particular memory type before spending
+		 * time to map/copy the buffer into that type of
+		 * memory.
+		 */
+		struct {
+			enum omapdss_buffer_type ba_type;
+			enum omapdss_buffer_type uv_type;
+		};
+
+		/* kernel-space interfaces */
+
+		/*
+		 * for fbmem, highest 4-bits of address is fb index,
+		 * rest of the bits are the offset
+		 */
+		struct {
+			__u32 ba;	/* base address or index */
+			__u32 uv;	/* uv address */
+		};
+	};
+};
+
+/*
+ * DSS2 manager information.
+ *
+ * The following information is deemed to be set globally, so it is not
+ * included:
+ *   gamma correction
+ *   whether to enable zorder (always enabled)
+ *   whether to replicate/truncate color fields (it is decided per the
+ *   whole manager/overlay settings, and is enabled unless overlay is
+ *   directed to WB.)
+ * Notes:
+ *
+ * 1) trans_key_type and trans_enabled only need to be filled if
+ *    trans_enabled is true, and alpha_blending is false.
+ */
+struct dss2_mgr_info {
+	__u32 ix;		/* display index same as sysfs/display# */
+
+	__u32 default_color;
+
+	enum omap_dss_trans_key_type trans_key_type;
+	__u32 trans_key;
+	struct omap_dss_cpr_coefs cpr_coefs;
+
+	__u8 trans_enabled;	/* bool */
+
+	__u8 interlaced;	/* bool */
+	__u8 alpha_blending;	/* bool - overrides trans_enabled */
+	__u8 cpr_enabled;	/* bool */
+	__u8 swap_rb;		/* bool - swap red and blue */
+} __aligned(4);
+
+/*
+ * ioctl: DSSCIOC_SETUP_MGR, struct dsscomp_setup_mgr_data
+ *
+ * 1. sets manager of each ovl in composition to the display
+ * 2. calls set_dss_ovl_info() for each ovl to set up the
+ *    overlay staging structures (this is a wrapper around ovl->set_info())
+ * 3. calls set_dss_mgr_info() for mgr to set up the manager
+ *    staging structures (this is a wrapper around mgr->set_info())
+ * 4. if update is true:
+ *      calls manager->apply()
+ *      calls driver->update() in a non-blocking fashion
+ *      this will program the DSS synchronously
+ *
+ * Notes:
+ *
+ * 1) x, y, w, h only needs to be set if update is true.
+ *
+ * All non-specified pipelines that currently are on the same display
+ * will remain the same as on the previous frame.  You may want to
+ * disable unused pipelines to avoid surprises.
+ *
+ * If get_sync_obj is false, it returns 0 on success, <0 error value
+ * on failure.
+ *
+ * If get_sync_obj is true, it returns fd on success, or a negative value
+ * on failure.  You can use the fd to wait on (using DSSCIOC_WAIT ioctl()).
+ *
+ * Note: frames do not get eclipsed when the display turns off.  Queue a
+ * blank frame to eclipse old frames.  Blank frames get eclipsed when
+ * programmed into DSS.
+ *
+ * (A blank frame is queued to the display automatically in Android before
+ * the display is turned off.)
+ *
+ * All overlays to be used on the frame must be listed.  There is no way
+ * to add another overlay to a defined frame.
+ */
+enum dsscomp_setup_mode {
+	DSSCOMP_SETUP_MODE_APPLY = (1 << 0),	/* applies changes to cache */
+	DSSCOMP_SETUP_MODE_DISPLAY = (1 << 1),	/* calls display update */
+	DSSCOMP_SETUP_MODE_CAPTURE = (1 << 2),	/* capture to WB */
+
+	/* just apply changes for next vsync/update */
+	DSSCOMP_SETUP_APPLY = DSSCOMP_SETUP_MODE_APPLY,
+	/* trigger an update (wait for vsync) */
+	DSSCOMP_SETUP_DISPLAY =
+			DSSCOMP_SETUP_MODE_APPLY | DSSCOMP_SETUP_MODE_DISPLAY,
+	/* capture to WB - WB must be configured */
+	DSSCOMP_SETUP_CAPTURE =
+			DSSCOMP_SETUP_MODE_APPLY | DSSCOMP_SETUP_MODE_CAPTURE,
+	/* display and capture to WB - WB must be configured */
+	DSSCOMP_SETUP_DISPLAY_CAPTURE =
+			DSSCOMP_SETUP_DISPLAY | DSSCOMP_SETUP_CAPTURE,
+};
+
+struct dsscomp_setup_mgr_data {
+	__u32 sync_id;		/* synchronization ID - for debugging */
+
+	struct dss2_rect_t win; /* update region, set w/h to 0 for fullscreen */
+	enum dsscomp_setup_mode mode;
+	__u16 num_ovls;		/* # of overlays used in the composition */
+	__u16 get_sync_obj;	/* ioctl should return a sync object */
+
+	struct dss2_mgr_info mgr;
+	struct dss2_ovl_info ovls[0]; /* up to 5 overlays to set up */
+};
+
+/*
+ * ioctl: DSSCIOC_CHECK_OVL, struct dsscomp_check_ovl_data
+ *
+ * DISPLAY and/or CAPTURE bits must be filled for the mode field
+ * correctly to be able to decide correctly if DSS can properly
+ * render the overlay.
+ *
+ * ovl.ix is ignored.
+ *
+ * Returns a positive bitmask regarding which overlay of DSS can
+ * render the overlay as it is configured for the display/display's
+ * manager.  NOTE: that overlays that are assigned to other displays
+ * may be returned.  If there is an invalid configuration (negative
+ * sizes, etc.), a negative error value is returned.
+ *
+ * ovl->decim's min values will be modified to the smallest decimation that
+ * DSS can use to support the overlay configuration.
+ *
+ * Assumptions:
+ * - zorder will be distinct from other pipelines on that manager
+ * - overlay will be enabled and routed to the display specified
+ */
+struct dsscomp_check_ovl_data {
+	enum dsscomp_setup_mode mode;
+	struct dss2_mgr_info mgr;
+	struct dss2_ovl_info ovl;
+};
+
+/*
+ * This structure is used to set up the entire DISPC (all managers),
+ * and is analogous to dsscomp_setup_mgr_data.
+ *
+ * Additional features:
+ * - all overlays that were specified in a prior use of this
+ * structure, and are no longer specified, will be disabled.
+ * - 1D buffers under 4M will be mapped into TILER1D.
+ *
+ * Limitations:
+ * - only DISPLAY mode is supported (DISPLAY and APPLY bits will
+ *   automatically be set)
+ * - getting a sync object is not supported.
+ */
+struct dsscomp_setup_dispc_data {
+	__u32 sync_id;		/* synchronization ID - for debugging */
+
+	enum dsscomp_setup_mode mode;
+	__u16 num_ovls;		/* # of overlays used in the composition */
+	__u16 num_mgrs;		/* # of managers used in the composition */
+	__u16 get_sync_obj;	/* ioctl should return a sync object */
+
+	struct dss2_mgr_info mgrs[3];
+	struct dss2_ovl_info ovls[5]; /* up to 5 overlays to set up */
+};
+
+/*
+ * ioctl: DSSCIOC_WB_COPY, struct dsscomp_wb_copy_data
+ *
+ * Requirements:
+ *	wb.ix must be OMAP_DSS_WB.
+ *
+ * Returns 0 on success (copy is completed), non-0 on failure.
+ */
+struct dsscomp_wb_copy_data {
+	struct dss2_ovl_info ovl, wb;
+};
+
+/*
+ * ioctl: DSSCIOC_QUERY_DISPLAY, struct dsscomp_display_info
+ *
+ * Gets informations about the display.  Fill in ix and modedb_len before
+ * calling ioctl, and rest of the fields are filled in by ioctl.  Up to
+ * modedb_len timings are retrieved in the order of display preference.
+ *
+ * Returns: 0 on success, non-0 error value on failure.
+ */
+struct dsscomp_display_info {
+	__u32 ix;			/* display index (sysfs/display#) */
+	__u32 overlays_available;	/* bitmask of available overlays */
+	__u32 overlays_owned;		/* bitmask of owned overlays */
+	enum omap_channel channel;
+	enum omap_dss_display_state state;
+	__u8 enabled;			/* bool: resume-state if suspended */
+	struct omap_video_timings timings;
+	struct s3d_disp_info s3d_info;	/* any S3D specific information */
+	struct dss2_mgr_info mgr;	/* manager information */
+	__u16 width_in_mm;		/* screen dimensions */
+	__u16 height_in_mm;
+
+	__u32 modedb_len;		/* number of video timings */
+	struct dsscomp_videomode modedb[];	/* display supported timings */
+};
+
+/*
+ * ioctl: DSSCIOC_SETUP_DISPLAY, struct dsscomp_setup_display_data
+ *
+ * Gets informations about the display.  Fill in ix before calling
+ * ioctl, and rest of the fields are filled in by ioctl.
+ *
+ * Returns: 0 on success, non-0 error value on failure.
+ */
+struct dsscomp_setup_display_data {
+	__u32 ix;			/* display index (sysfs/display#) */
+	struct dsscomp_videomode mode;	/* video timings */
+};
+
+/*
+ * ioctl: DSSCIOC_WAIT, struct dsscomp_wait_data
+ *
+ * Use this ioctl to wait for one of the following events:
+ *
+ * A) the moment a composition is programmed into DSS
+ * B) the moment a composition is first displayed (or captured)
+ * C) the moment when a composition is no longer queued or displayed on a
+ * display (it is released).  (A composition is assumed to be superceded
+ * when another composition has been programmed into DSS, even if that
+ * subsequent composition does not update/specify all overlays used by
+ * the prior composition; moreover, even if it uses the same buffers.)
+ *
+ * Set timeout to desired timeout value in microseconds.
+ *
+ * This ioctl must be used on the sync object returned by the
+ * DSSCIOC_SETUP_MGR or DSSCIOC_SETUP_DISPC ioctls.
+ *
+ * Returns: >=0 on success, <0 error value on failure (e.g. -ETIME).
+ */
+enum dsscomp_wait_phase {
+	DSSCOMP_WAIT_PROGRAMMED = 1,
+	DSSCOMP_WAIT_DISPLAYED,
+	DSSCOMP_WAIT_RELEASED,
+};
+
+struct dsscomp_wait_data {
+	__u32 timeout_us;	/* timeout in microseconds */
+	enum dsscomp_wait_phase phase;	/* phase to wait for */
+};
+
+/* IOCTLS */
+#define DSSCIOC_SETUP_MGR	_IOW('O', 128, struct dsscomp_setup_mgr_data)
+#define DSSCIOC_CHECK_OVL	_IOWR('O', 129, struct dsscomp_check_ovl_data)
+#define DSSCIOC_WB_COPY		_IOW('O', 130, struct dsscomp_wb_copy_data)
+#define DSSCIOC_QUERY_DISPLAY	_IOWR('O', 131, struct dsscomp_display_info)
+#define DSSCIOC_WAIT		_IOW('O', 132, struct dsscomp_wait_data)
+
+#define DSSCIOC_SETUP_DISPC	_IOW('O', 133, struct dsscomp_setup_dispc_data)
+#define DSSCIOC_SETUP_DISPLAY	\
+			_IOW('O', 134, struct dsscomp_setup_display_data)
+#endif
diff --git a/include/video/omap_hwc.h b/include/video/omap_hwc.h
new file mode 100644
index 0000000..916e095
--- /dev/null
+++ b/include/video/omap_hwc.h
@@ -0,0 +1,27 @@
+#ifndef _LINUX_OMAP_HWC_H
+#define _LINUX_OMAP_HWC_H
+
+struct rgz_blt_entry {
+	struct bvbltparams bp;
+	struct bvsurfgeom dstgeom;
+	struct bvsurfgeom src1geom;
+	struct bvbuffdesc src1desc;
+	struct bvsurfgeom src2geom;
+	struct bvbuffdesc src2desc;
+};
+
+struct omap_hwc_blit_data {
+	/* if rgz_items is 0 there is nothing to blit */
+	__u16 rgz_items;
+	struct rgz_blt_entry rgz_blts[0];
+};
+
+/*
+ * This structure is passed down from the Android HWC HAL
+ */
+struct omap_hwc_data {
+	struct dsscomp_setup_dispc_data dsscomp_data;
+	struct omap_hwc_blit_data blit_data;
+};
+
+#endif
-- 
1.7.5.4

